---
title: "组合与多项式"
author: forgottencsc
date: Nov 18, 2019
geometry: margin=1cm
output: pdf_document
---

## 容斥原理与子集卷积

### $<2^S,\subseteq>$上的$\zeta$变换与$\mu$变换

定义：

$$(\zeta f)(S)=\sum_{T \subseteq S}{f(T)}$$

$$(\mu f)(S)=\sum_{T \subseteq S}{(-1)^{|S|-|T|}f(T)}$$

定理：

$$(\zeta (f+g))(S)=(\zeta f)(S)+(\zeta g)(S)$$

证明显然。

定理：

$$(\mu \zeta f)(S) = (\zeta \mu f)(S)=f(S)$$

也可写作：

$$ g(S)=\sum_{T\subseteq S}{f(T)}\Rightarrow f(S)=\sum_{T\subseteq S}{(-1)^{|S|-|T|}g(T)}$$

证明：

$$
(\mu \zeta f)(S)
=\sum_{T \subseteq S}{(\zeta f)(T)}
=\sum_{T\subseteq S}{(-1)^{|S|-|T|}\sum_{U\subseteq T}{f(U)}}
$$
$$
=\sum_{U\subseteq S}{f(U)\sum_{U\subseteq T \subseteq S}{(-1)^{|S|-|T|}}}
=\sum_{U\subseteq S}{f(U)\sum_{V\subseteq S-U}{(-1)^{|V|}}}
$$
$$
=\sum_{U\subseteq S}{f(U)[|S]-|U|=0]}
=f(S)
$$

注：同时有

$$
    g(S)=\sum_{T \supseteq S}{f(T)}\Rightarrow f(S)=\sum_{T\supseteq S}{(-1)^{|T|-|S|}g(T)}
$$

定义：容斥原理背景

设有许多性质$P_i$,性质的全集为$U$, $A_i=\{x|P_i(x)\}$表示满足第$i$个性质的集合

对于一些性质的集合$S$,定义

$$f(S)=\{x|\exists i \in S,P_i(x)\}=\left|\bigcup_{i\in S}{A_i}\right|$$

$$g(S)=\{x|\forall i \in S, P_i(x)\}=\left|\bigcap_{i\in S}{A_i}\right|$$

$$ h(S)=\{x|(\forall i \in S, P_i(x))\wedge(\forall i \notin S, \neg P_i(x)\} 
=\left|\bigcap_{i\in S}{A_i}-\bigcup_{i\notin S}{A_i}\right|
$$

则由定义有：

$$ f(U)=\sum_{\emptyset \neq S\subseteq U}{h(S)}$$

$$ g(T)=\sum_{S \supseteq T}{h(S)}$$

### 容斥原理

$$ f(U)=\sum_{\emptyset \neq T \subseteq U} {(-1)^{|T|+1}g(T)}$$

证明：

$$
f(U)=\sum_{\emptyset \neq S \subseteq U}{h(S)}
=\sum_{\emptyset \neq S \subseteq U}{\sum_{T\supseteq S}{(-1)^{|T|-|S|}g(T)}}
=\sum_{\emptyset \neq T \subseteq U}{(-1)^{|T|}g(T)\sum_{\emptyset \neq S\subseteq T}{(-1)^{|S|}}}
$$
$$
=\sum_{\emptyset \neq T \subseteq U}{(-1)^{|T|}g(T)}(\sum_{S\subseteq T}{(-1)^{|S|}-(-1)^{|\emptyset |})}
=\sum_{\emptyset \neq T \subseteq U}{(-1)^{|T|-1}g(T)}
$$

即：
$$\left|\bigcup_{i\in S}{A_i}\right|=\sum_{k=1}^{|S|}{(-1)^{k-1}\sum_{T\subseteq |S|,|T|=k}{\left|\bigcap_{i \in T}{A_i}\right|}}$$

扩展：由

$$\left|{\bigcap_{i\in S}{A_i}}\right|=|U|-\left|\bigcup_{i\in S}{(\overline{A_i})}\right|$$

可对交集的大小进行计算。

### 子集卷积

给定环$R=<S,+,\cdot >与$函数$f: 2^S \rightarrow R,g:2^S \rightarrow R$

定义$f$与$g$的子集卷积为：

$$(f * g)(S)=\sum_{T\subseteq S}f(T)g(S-T)=\sum_{T_1 \cup T_2 = S \wedge T_1 \cap T2 = \emptyset}f(T_1)g(T_2)$$

定义$f$与$g$的覆盖积为：

$$(f *_c g)(S)=\sum_{T_1 \cup T_2 = S}f(T_1)g(T_2)$$

注意到

$$
(\zeta (f *_c g))(S)=\sum_{T\subseteq S}\sum_{T_1 \cup T_2=T}f(T_1)g(T_2)=\sum_{T_1\subseteq S}\sum_{T_2 \subseteq S}f(T_1)g(T_2)
$$

$$
=\sum_{T_1\subseteq S} f(T_1) \sum_{T_2 \subseteq S}g(T_2)=(\zeta f)(S) (\zeta g)(S)
$$

因此覆盖积可在$O(w 2^w)$内计算出来，这里$w=|S|$。

为计算子集卷积，需对$f$和$g$分别构造另外$w$个函数$f_i,g_i$。这里$f_i(S)=[|S|=i]f(S)$。

$$
\sum_{i=0}^{|S|}(f_i *_c g_{|S|-i})(S)=\sum_{i=0}^{|S|}\sum_{T_1 \cup T_2 =S}{f_i(T_1)g_{|S|-i}(T_2)}=\sum_{i=0}^{|S|}\sum_{T_1 \cup T_2=S}{[T_1=i][T_2=|S|-i]f(T_1)g(T_2)}
$$

$$
=\sum_{T_1 \cup T_2 =S\wedge T_1 \cap T_2 = \emptyset}f(T_1)g(T_2)=(f * g)(S)
$$

计算过程：

$$(f * g)_{|S|}=\sum_{i=0}^{|S|}(f_i *_c g_{|S|-i})=\sum_{i=0}^{|S|}(\mu)(\zeta f_i \cdot \zeta g_{|S|-i})=(\mu)\sum_{i=0}^{|S|}(\zeta f_i \cdot \zeta g_{|S|-i})$$

## 生成函数

### 常见级数

$$e^x=\sum_{k=0}^\infty{\frac{x^k}{k!}}=1+x+\frac{x^2}{2}+\frac{x^3}{6}+...$$

$$\ln(x+1)=\sum_{k=1}^\infty{\frac{(-1)^{k+1}}{k}x^k}=x-\frac {x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+... $$

$$-\ln(1-x)=\sum_{k=1}^\infty{\frac{x^k}{k}}=x+\frac{x^2}{2}+\frac{x^3}{3}+\frac{x^4}{4}+...$$

$$\frac{1}{1-x}=\sum_{k=0}^\infty{x^k}=1+x+x^2+x^3+...$$

### 一般生成函数

定义：一个序列$\{a_i\}$的生成函数(OGF)为$$F(x)=\sum_{i=0}^{\infty}{a_ix^i}$$

易得两个生成函数的乘积即为对应序列的卷积：

$$H(x)=F(x)G(x)=\sum_{i=0}^{\infty}{c_ix^i}=\sum_{i=0}^\infty{\left(\sum_{j=0}^{i}{a_jb_{i-j}}\right)x^i}$$

即

$$c_i=\sum_{j=0}^{i}{a_jb_{i-j}}$$

注：一般生成函数的系数可看作某种组合方案，两个一般生成函数的卷积的第$i$项系数的意义（即上式）可看作对从第一个集合中选$j$个，第二个集合中选$i-j$个的组合的方案数求和。

### 指数生成函数

定义：一个序列$\{a_i\}$的指数生成函数(EGF)为$$F(x)=\sum_{i=0}^{\infty}{a_i\frac{x^i}{i!}}$$

易得两个指数生成函数的乘积即为对应序列的带二项式系数的卷积：

$$H(x)=F(x)G(x)=\sum_{i=0}^{\infty}{c_i\frac{x^i}{i!}}
$$
$$
=\sum_{i=0}^\infty{\left(\sum_{j=0}^{i}{i!\frac{a_j}{j!}\frac{b_{i-j}}{(i-j)!}}\right)\frac{x^i}{i!}}=\sum_{i=0}^\infty{\left(\sum_{j=0}^i{\binom{i}{j}a_jb_{i-j}}\right)\frac{x^i}{i!}}
$$

即

$$c_i=\sum_{j=0}^{i}{\binom{i}{j}a_jb_{i-j}}$$

注：指数生成函数的系数可看作某种排列方案，两个指数生成函数的卷积的第$i$项系数的意义（即上式）可看作对从第一个集合中选$j$个，第二个集合中选$i-j$个，并将i个位置中的j个钦定为从第一个集合中选出来的，余下$i-j$个钦定为从第二个集合中选出来的的所有排列的方案数求和。（因此有个组合数作为系数）

### $e^{F(x)}$的组合意义

定义：合法集合与合法划分

将满足某些性质的集合定义为合法集合。
将一个集合划分为多个合法集合的划分方案定义为合法划分。

若$F(x)$为表示大小为$n$的合法集合有多少种的生成函数，则$\frac{F(x)^k}{k!}$为将大小为$n$的集合划分为$k$份合法集合的合法划分数的生成函数。

如大小为$n$的无向图有$2^{\frac{1}{2}n(n-1)}$种，则对应的合法集合可设为大小为$n$的连通图。枚举划分为的集合数并求和可得到

$$G(x)=\sum_{k=0}^\infty{\frac{F(x)^k}{k!}}$$

即$G(x)=e^{F(x)}$，或$F(x)=lnG(x)$

### 常见数列的生成函数

$$F_i: F(x)=1+xF(x)+x^2F(x)\Rightarrow F(x)=\frac{1}{1-x-x^2}$$

## 常见计数序列

### 斐波那契数

性质：

$$F_n=\frac{1}{\sqrt 5}\left[\left(\frac{1+\sqrt 5}{2}\right)^n-\left(\frac{1-\sqrt 5}{2}\right)^n\right]$$

$$\sum_{k=1}^{n}{F_k}=F_{n+2}-1$$

$$\sum_{k=1}^{n}{F_k}=F_nF_{n+1}$$

$$\sum_{k=1}^{n}{F_{2k-1}}=F_{2n}$$

$$\sum_{k=1}^{n}{F_{2k}}=F_{2n+1}-1$$

$$F_n=F_mF_{n-m+1}+F_{m-1}F_{n-m}$$

$$F_{n-1}F_{n+1}=F_n^2+(-1)^n$$

$$gcd(F_n,F_m)=F_{gcd(n,m)}$$

$$n|m \Leftrightarrow F(n)|F(m)$$

### 二项式系数

定义：

$$\binom{n}{k}=\frac{n!}{k!(n-k)!}$$

常见恒等式：

$$\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}$$

$$\binom{n}{k}=\frac{n}{k}\binom{n-1}{k-1}$$

$$\sum_{k=0}^n{\binom{m+k}{k}}=\binom{m+n+1}{n}$$

$$\sum_{k=0}^n{\binom{k}{m}}=\binom{n+1}{m+1}$$

$$\sum_{k=0}^{n}{\binom{m_1}{k}\binom{m_2}{n-k}}=\binom{m_1+m_2}{n}$$

### 卡特兰数

性质：

$$C_n=\frac{1}{n+1}\binom {2n}{n}$$

$$C_n=\prod_{k=2}^n{\left(1+\frac nk\right)}$$

$$C_n=\sum_{k=0}^{n-1}{C_{k}C_{n-k-1}}$$

|$n=$|0|1|2|3|4|5|6|7|8|9|10|
|-|-|-|-|-|-|-|-|-|-|-|-|
|$C_n$|1|1|2|5|14|42|132|429|1430|4862|16796|

OGF：$F(x)=1+xF(x)^2=\frac{1-\sqrt{1-4x}}{2x}=\frac{2}{1+\sqrt{1-4x}}$

### 默慈金数

定义：$M_n$表示从$(0,0)$开始每次向右上或正右或右下走一格且不走到第四象限的情况下走到$(n,0)$的方案总数。

$M_n$表示在$n$个点的圆上画出数条不相交弦的全部方法的总数。

性质：

$$M_n=\frac{(2(n-1)+3)M_{n-1}+(3(n-2)+3)M_{n-2}}{n+2}$$

$$M_n=M_{n-1}+\sum_{k=0}^{n-2}{M_kM_{n-2-k}}=\sum_{k=0}^{\left\lfloor\frac{n}{2}\right\rfloor}{\binom{n}{2k}C_k}$$

OGF:$F(x)=xF(x)+x^2F^2(x)=\frac{1-x-\sqrt{1-2x-3x^2}}{2x^2}=\frac{2}{1-x+\sqrt{1-2x-3x^2}}$

注：$C_k$为卡塔兰数。

|n=|0|1|2|3|4|5|6|7|8|9|10|
|-|-|-|-|-|-|-|-|-|-|-|-|
|$M_n$|1|1|2|4|9|21|51|127|323|835|2188|

### 那罗延数

定义：$N(n,k)$表示长度为$2n$的合法括号序列中有$k$对直接相邻的左右括号的方案数。

性质：

$$N(n,k)=\frac{1}{n}\binom{n}{k-1}\binom{n}{k}$$

$$\sum_{k=1}^{n}{N(n,k)}=C_{n}$$

注：$C_k$为卡塔兰数。

|n\k|1|2|3|4|5|6|7|8|
|-|-|-|-|-|-|-|-|-|
|1|1|
|2|1|1|
|3|1|3|1|
|4|1|6|6|1|
|5|1|10|20|10|1|
|6|1|15|50|50|15|1|
|7|1|21|105|175|105|21|1|
|8|1|28|196|490|490|196|28|1|

### 第一类斯特林数

定义：$s(n,m)$表示将大小为$n$的集合划分成$m$个圆排列的方案数

考虑$n$所在排列（加入某个圆排列或单独作为一个新的圆排列）可得到递推式：

$$s(n,m)=s(n-1,m-1)+(n-1)s(n-1,m)$$

特别的，$s(n,0)=[n==0]$

注：每个圆排列可被视作一个置换，因而$$\sum_{k=0}^n{s(n,k)}=n!$$

行的OGF：

由递推式有$$s_n(x)=xs_{n-1}(x)+(n-1)s_{n-1}=(x+n-1)s_{n-1}(x)=\prod_{i=0}^{n-1}{(x+i)}$$

列的EGF:

单一圆排列的EGF为

$$\sum_{k=1}^{\infty}{\frac{(k-1)!x^k}{k!}}=\sum_{k=1}^{\infty}{\frac{x^k}{k}}=-\ln(1-x)$$

卷$m$次后除去$m!$消除圆排列之间的先后顺序即可得到第一类斯特林数的EGF

$$s_m(x)=\frac{\left(-\ln(1-x)\right)^m}{m!}$$

注：上式是无符号第一类斯特林数的EGF，带符号的为

$$s_m(x)=\frac{\left(\ln(1+x)\right)^m}{m!}$$

|n/m|0|1|2|3|4|5|6|7|8|
|-|-|-|-|-|-|-|-|-|-|
|0|1|
|1|0|1|
|2|0|1|1|
|3|0|2|3|1|
|4|0|6|11|6|1|
|5|0|24|50|35|10|1|
|6|0|120|274|225|85|15|1|
|7|0|720|1764|1624|735|175|21|1|
|8|0|5040|13068|13132|6769|1960|322|28|1|

### 第二类斯特林数

定义：$S(n,m)$表示将大小为$n$的集合划分成$m$个非空集合的方案数

考虑$n$所在集合（加入$m$个集合中的一个或单独作为一个新的集合）可得到递推式：

$$S(n,m)=S(n-1,m-1)+mS(n-1,m)$$

考虑容斥，给每个集合编号后设$A_i$为第$i$个集合为空的放法，则所求为$\bar{A_i}$的交，即

$$m!S(n,m)=m^n-\sum_{k=1}^{m}{(-1)^{k-1}\binom mk(m-k)^n}$$

得

$$S(n,m)=\frac{1}{m!}\sum_{k=0}^m{(-1)^{k-1}\binom mk (m-k)^n}$$

性质：

考虑将$m$个物品分入$n$个盒子的方案数，枚举有$k$个有物品的盒子，可得

$$m^n=\sum_{k=0}^mS(m,k)\binom nk k!$$

二项式反演可得

$$k!S(m,k)=\sum_{n=0}^k(-1)^{k-n}\binom kn n^m$$

此式与上式等价。

行的OGF:

由通项公式得

$$S_n(x)=\sum_{k=0}^{n}{\frac {x^k}{k!}\sum_{i=0}^k{(-1)^{i}\binom ki (k-i)^n}}=\sum_{k=0}^{n}{x^k\left(\sum_{i=0}^{k}{\frac{(-1)^{i}}{i!}\frac{(k-i)^n}{(k-i)!}}\right)}$$

列的OGF:由递推式有：

$$S_m(x)=xS_{m-1}(x)+mxS_{m}(x)$$

得

$$S_m(x)=\frac{x}{1-mx}S_{m-1}(x)=\frac{x^m}{\prod_{i=1}^{m}{1-ix}}$$

|n/m|0|1|2|3|4|5|6|7|8|
|-|-|-|-|-|-|-|-|-|-|
|0|1|
|1|0|1|
|2|0|1|1|
|3|0|1|3|1|
|4|0|1|7|6|1|
|5|0|1|15|25|10|1|
|6|0|1|31|90|65|15|1|
|7|0|1|63|301|350|140|21|1|
|8|0|1|127|966|1701|1050|266|28|1|

### 贝尔数

定义：贝尔数$B_n$表示将$n$化为至少一个非空集合的方案数。

性质：

$$B_n=\sum_{k=1}^nS(n,k)$$

注：$S(n,k)$为第二类斯特林数。

EGF: $F(x)=e^{e^x-1}$

|n=|0|1|2|3|4|5|6|7|8|9|10|
|-|-|-|-|-|-|-|-|-|-|-|-|
|$B_n$|1|1|2|5|15|52|203|877|4140|21147|115975|

### 伯努利数

$$B_0=1,n \geq 1 \Rightarrow B_{2n+1}=0$$

$$n \geq 1 \Rightarrow \sum_{k=0}^{n}{\binom{n+1}{k}B_k}=0$$

EGF:$F(x)=\frac{x}{e^x-1}$

### 等幂求和

考虑$S_k(n)=\sum_{i=1}^{n}{i^k}$的生成函数$G_n$

$$G_n(x)=\sum_{k=0}^{\infty}{\frac{x^k}{k!}\sum_{i=1}^{n}{i^k}}$$

$$=\sum_{i=1}^{n}{\sum_{k=0}^{\infty}{\frac{(xi)^k}{k!}}}$$

$$=\sum_{i=1}^{n}{e^{xi}}=\frac{e^x(1-e^{xn})}{1-e^x}$$

$$\sum_{i=1}^{n}{i^k}=\frac{1}{k+1}\sum_{i=0}^{k}{(-1)^i\binom{k+1}{i}B_in^{k+1-i}}$$

### 五边形数与拆分数

拆分数：$a_n=|\{S|\forall b \in S, b > 0 \wedge b = \sum_{b \in S} b\}|$，即将$n$拆成数个正整数的方案。

不难列出

拆分数的OGF:

$$
F(x)=\prod_{i=1}^{\infty}\sum_{j=0}^\infty{x^{ij}}=\prod_{i=1}^{\infty}{\frac{1}{1-x^i}}
$$

和五边形数相关的神奇函数：

$$
P(x)=\prod_{i=1}^\infty(1-x^i)=\sum_{i=0}^\infty{(-1)^ix^{\frac{1}{2}i(3i \pm 1)}}
$$

易得

$$
F(x)P(x)=1
$$

若限定每个数至多用$k$次，则有OGF:

$$
F_k(x)=\prod_{i=1}^{\infty}\sum_{j=0}^k{x^{ij}}=\prod_{i=1}^{\infty}{\frac{1-x^{(k+1)i}}{1-x^i}}=P(x^{k+1})F(x)
$$

注：$P(x)$前$n$项的系数只有$O(\sqrt{n})$个非零项，因此在预处理出$F(x)$的条件下可在$O(\sqrt{n})$内算出$F_k(x)$的第$n$项系数。

## 反演（证明待补充）

### 二项式反演

|$g_n=\sum_{k=0}^n{\binom n k f_k}$|$g_k=\sum_{n=k}^m{\binom n k f_n}$|
|----|----|
|$f_n=\sum_{k=0}^n{(-1)^{n-k}\binom n k g_k}$|$f_k=\sum_{n=k}^m{(-1)^{n-k}\binom n k g_n}$|

### 斯特林反演

|$g_n=\sum_{k=0}^n{S(n,k) f_k}$|
|----|----|
|$f_n=\sum_{k=0}^n{(-1)^{n-k}s(n,k) g_k}$|

注：其中$s(n,k)$为第一类斯特林数，$S(n,k)$为第二类斯特林数。

### min-max反演

$$\max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}\min(T)$$

$$\min(S)=\sum_{T\subseteq S}(-1)^{|T|+1}\max(T)$$

$$kth\max(S)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\min(T)$$

注：$\max$与$\min$在框上期望后依然成立。

## 图计数

### Prufer序列

定义：一棵有标号树的Prufer序列为递归地将其最小的叶节点删去并将其邻点标号加入序列末尾直到剩余两个点所得序列。

Prufer序列转化为树：

维护一个集合$S$，初始$S=\{1,2,...,n\}$。对于序列中从左到右的每个元素$u$，找到未在其右侧出现的$S$中的最小元素$v$并将$u,v$连边，然后将$v$从$S$中删去，最后将$S$中剩余两个点连边即可完成对树的还原。

扩展——森林的Prufer序列：

定义：一个$n$个点的有$k$个连通块组成的森林的Prufer序列与树的构造方式几乎相同，唯一的区别是剩余$k+1$个点时停止。易得$n$个点$k$个连通块组成的森林的$Prufer$序列长度为$n-k$

1. 先钦定$k$个根

2. 第$n-k$个位置的值为$k$个根之一。

3. 前$n-k-1$个位置上的值任意。

不难得到$n$个点，有$k$个连通块的森林数量为$\binom nk kn^{n-k-1}$

### 有标号无根树计数

定理(Caylay)：$n$个点的有标号无根树共有$n^{n-2}$种。从Prufer序列的构造与还原不难看出一棵树对应着一个Prufer序列，而每个Prufer序列在其$n-2$个位置均有$n$种取值可能。

法2：

枚举叶子个数$k$，可得到

当$0 \leq n \leq 2$时有$F(n)=1$，否则有$F(n)=\sum_{k=1}^{n-1}{\binom nk (n-k)^{k}F(n-k)}$

### 有标号有根树计数

给每个有标号无根树定一个根即可得到有标号有根树，因而$n$个点的有标号有根树共有$n^{n-1}$种。

### 有标号基环树计数

考虑魔改Prufer序列，先钦定$k$个点在环上，方案为$\binom nk$。

将环上的边都断开并将所有环上的点连向一个标号为正无穷的特殊点。

该树的Prufer序列具有如下性质：

1. 最后$k$个位置的值均为正无穷。

2. 第$n-k$个位置的值必为环上的$k$个点之一。

3. 前$n-k-1$个位置上的值任意。

k个点的环排列有$\frac{1}{2}k!$种，因而$n$个点的基环树个数为

$$
\sum_{k=3}^n{\binom nk \frac{k!}{2}n^{n-k-1}}=\frac 12 \sum_{k=3}^n{\frac{n!}{(n-k)!}n^{n-k-1}}
$$

考虑$n$个点基环树数量的OGF:

$$
F(x)=\frac 12 \sum_{i=0}^\infty\frac{x^i}{i!}\sum_{k=3}^i\frac{i!}{(i-k)!}i^{i-k-1}=\frac 12 \sum_{i=0}^\infty\frac{x^i}{i!}\sum_{k=0}^{i-3}\frac{i!}{k!}i^{k-1}=\frac 12 \sum_{i=0}^\infty x^i\sum_{k=0}^{i-3}\frac{i^{k-1}}{k!}
$$

### 有标号连通图计数

对于满足某些性质的图（如欧拉图，即顶点度数均为偶数），用可以不连通的所有方案推广到连通的所有方案的情况可通过将所有方案减去不连通的方案获得。如枚举$1$号点所在连通块大小$k$，则除$1$号点之外的点共有$\binom{n-1}{k-1}$种方案：

$$f_n=g_n-\sum_{k=1}^{n-1}{\binom{n-1}{k-1}f_kg_{n-k}}$$

也可通过指数生成函数进行计数，即$G(x)=lnF(x)$，其中$F(x),G(x)$分别为$f_n,g_n$的EGF。具体见“$e^{F(x)}$的组合意义”

### 有标号二分图计数

法1：

设大小为$n$，有$m$个连通块的二分图数量为$F(n,m)$，则有：

$$F(n,m)=\sum_{k=1}^{n-m+1}{\binom{n-1}{k-1}F(k,1)F(n-k,m-1)}$$

设$G(n)$为大小为$n$，进行了黑白染色的二分图数量，则有:

$$G(n)=\sum_{m=0}^n{\binom{n}{m}2^{m(n-m)}}=\sum_{m=1}^n{2^mF(n,m)}$$

$$=2^1F(n,1)+\sum_{m=2}^n{2^m\sum_{k=1}^{n-m+1}{\binom{n-1}{k-1}F(k,1)F(n-k,m-1)}}$$

$$=2F(n,1)+\sum_{k=1}^{n-1}{\binom{n-1}{k-1}F(k,1)\sum_{m=2}^{n-k+1}{2^mF(n-k,m-1)}}$$

$$=2F(n,1)+2\sum_{k=1}^{n-1}{\binom{n-1}{k-1}F(k,1)\sum_{m=1}^{n-k}{2^mF(n-k,m)}}$$

$$=2F(n,1)+2\sum_{k=1}^{n-1}{\binom{n-1}{k-1}F(k,1)G(n-k)}$$

可得递推式:

$$F(n,1)=\frac{1}{2}G(n)-\sum_{k=1}^{n-1}{\binom{n-1}{k-1}{F(k,1)G(n-k)}}$$

注：
$$G(n)=\sum_{m=0}^n{\binom{n}{m}2^{m(n-m)}}=\sum_{m=0}^n{\binom{n}{m}2^{nm-m^2}}
=\sum_{m=0}^n{\frac{n!}{m!(n-m)!}2^{\frac{1}{2}(n^2+m^2-(n-m)^2)-m^2}}$$
$$=n!2^\frac{n^2}{2}\sum_{m=0}^n{\frac{1}{m!(n-m)!}2^{-\frac{(n-m)^2}{2}-\frac{m^2}{2}}}
=n!2^\frac{n^2}{2}\sum_{m=0}^n{\frac{2^{-\frac{(n-m)^2}{2}}}{m!}\frac{2^{-\frac{m^2}{2}}}{(n-m)!}}$$

法2：

考虑$n$个点的二染色的连通二分图的EGF为$H(x)$，二染色的二分图的EGF为$G(x)$，连通二分图的EGF为$F_1(x)$，二分图的EGF为$F_2(x)$，则显然$G(x)=e^{H(x)}$，且$H(x)=2F_1(x)$,$F_2(x)=e^{F_1(x)}$。

于是$F_2(x)=e^{F_1(x)}=e^{\frac{1}{2}H(x)}=e^{\frac{1}{2}lnG(x)}=\sqrt{G(x)}$。

### 有标号DAG计数

注意到DAG中存在一类特殊的点，即出度为$0$的点，我们通过枚举这些点进行计算。

设$F(n,S)$为$n$个点，有且仅有$S$中点出度为0的DAG数量。

设$G(n,S)$为$n$个点，至少有$S$中点出度为0的DAG数量。不难发现我们需要求的即是$G(n,\emptyset)$。

枚举$S$中点与其他点的连边，可得$G(n,S)=2^{|S|(n-|S|)}G(n-|S|,\emptyset)$

由$G$与$F$的定义可得

$$G(n,S)=\sum_{T \supseteq S}{F(n,T)}$$

$$F(n,S)=\sum_{T \supseteq S}{(-1)^{|T|-|S|}G(n,T)}$$

于是有

$$G(n,\emptyset)=\sum_{T \neq \emptyset}{F(n,T)}=\sum_{T \neq \emptyset}{\sum_{S\supseteq T}{(-1)^{|S|-|T|}G(n,S)}}$$

$$=\sum_{T \neq \emptyset}{\sum_{S\supseteq T}{(-1)^{|S|-|T|}2^{|S|(n-|S|)}G(n-|S|,\emptyset)}}$$

$$=\sum_{S\neq \emptyset}{(-1)^{|S|}2^{|S|(n-|S|)}G(n-|S|,\emptyset)\sum_{\emptyset \neq T\subseteq S}}{(-1)^{|T|}}$$

$$=\sum_{k=1}^{n}{(-1)^{k-1}\binom{n}{k}2^{k(n-k)}}G(n-k,\emptyset)$$

得到递推式：

$F(n)=\sum_{k=1}^n{(-1)^{k-1}\binom nk 2^{k(n-k)}F(n-k)}$

注：考虑上式的组合意义：

1. 从$n$个点中钦定$k$个点为0出度点有$\binom{n}{k}$种选法。

2. 其他$n-k$个点与$k$个点可以任意连边，方案数为$2^{k(n-k)}$。

3. 其他$n-k$个点之间共有$F(n-k)$种连边方式。

4. 因为任意连边可能造成这$k$个点之外的点出度也为0，所以式$\binom nk 2^{k(n-k)}F(n-k)$实际上是钦定了至少$k$个点为0出度点的$n$点DAG数量。

5. 考虑某种恰好有$k$个0出度点的DAG被哪些至少$i$个0出度点的方案统计了，可得重复统计次数为$\sum_{i=0}^{k}{\binom ki}=2^k$。不难发现加上容斥系数后即可使上式变为$\sum_{i=0}^{k}{\binom ki(-1)^{i+1}}=(-1)\sum_{i=0}^k{\binom ki(-1)^i}=\sum_{i=1}^k{\binom ki}(-1)^{i-1}-1$，因此给所有出度至少为$k$的DAG方案数乘上一个$(-1)^{k-1}$的容斥系数可保证所有方案均被统计恰好一次。

6. 因此$n$个点的DAG数量=至少$1$个点出度为0的$n$点DAG数量$-$至少$2$个点出度为0的$n$点DAG数量$+$至少$3$个点出度为$0$的$n$点DAG数量，等等。

### 有标号强连通图计数

设$n$的点的强连通图数量为$F(n)$，考虑用所有$n$个点的有向图的个数$H(n)$减去非强连通图的方案数来计算答案。

考虑DAG计数的过程，我们枚举非强连通图缩点后出度为$0$的强连通分量由哪些点组成，其他点与这些点之间可以任意连边。

可得：

$$F(n)=H(n)-\sum_{k=1}^{n}{\binom nk 2^{k(n-k)}H(n-k)G(k)}+F(n)$$

其中$G(k)$表示$k$个点组成数个互不相连的强连通分量的方案数。

右边加入$F(n)$的原因是，当$k$取到$n$时，该项表示的方案为$n$个点组成数个互不相连的强连通分量的方案数，即恰好包括了一个$F(n)$，因此要将其加回去。

由DAG计数可知，因为对$H(n-k)$中的连边方案没有任何限制，所以余下$n-k$个点中的点在缩点后也可能产生新的0出度点，即上述计数过程会造成重复统计。

我们仿照DAG计数，令$G(n,i)$表示$n$个点组成$i$个互不相连的强连通分量的方案数，并令$G(n)=\sum_{i=1}^{k}{(-1)^{i-1}G(n,i)}$,加入容斥系数来避免重复统计。

由前式可得关于$G(n)$的递推式：

$$H(n)=\sum_{k=1}^{n}{\binom nk 2^{k(n-k)}H(n-k)G(k)}$$

$$=\sum_{k=1}^{n-1}{\binom n k 2^{k(n-k)}H(n-k)G(k)}+G(n)$$

于是

$$G(n)=H(n)-\sum_{k=1}^{n-1}{\binom nk 2^{k(n-k)}H(n-k)G(k)}$$

考虑用$G(n)$获得$F(n)$的递推式，因为$F(n)=G(n,1)$，因此我们考虑通过枚举1号点所在强连通分量大小计算$\sum_{i=2}^{n}{(-1)^iG(n,i)}$然后加到$G(n)$上去。

$$F(n)=G(n,1)=G(n)+\sum_{i=2}^{n}{(-1)^iG(n,i)}$$

$$=G(n)+\sum_{i=2}^{n}{(-1)^i\sum_{k=1}^{n-i+1}{\binom {n-1}{k-1}G(k,1)G(n-k,i-1)}}$$

$$=G(n)+\sum_{k=1}^{n-1}{\binom {n-1}{k-1} G(k,1)\sum_{i=1}^{n-k}{(-1)^{i-1}G(n-k,i)}}$$

$$=G(n)+\sum_{k=1}^{n-1}{\binom {n-1}{k-1} F(k)G(n-k)}$$

注：$G(n,i)$可通过枚举1号点所在连通块大小获得递推式

$$G(n,i)=\sum_{k=1}^{n-i+1}{\binom {n-1}{k-1}G(k,1)G(n-k,i)}$$

## 群

### 群作用

### Burnside引理/Polya定理

给定作用于有限集$X$上的有限群$G$，这里我们直接考虑$G$的置换表示。

定义：

$T(x)=\{y \in X | \exists g \in G,y = gx\}$为$x$的$G$-轨道。

$x$的稳定化子$G_x=\{g|gx=x\}$

置换特征标$\chi(g)=\{x|gx=x\}$，即在$g$的作用下不变的$x$。

可以证明所有轨道构成了$X$的一个划分，即轨道两两不相交。

轨道-稳定化子定理：

$|T(x)||G_x|=|G|$

定理(Burnside):

$X$在$G$作用下的轨道数为

$$
\frac{1}{|G|}\sum_{g \in G}|\chi(g)|
$$

证明：

$$
轨道数=\sum_{x \in X}\frac 1 {|T(x)|}=\sum_{x \in X} \frac{|G_x|}{|G|}=\frac{1}{|G|}\sum_{x \in X}|G_x|
$$

$$
=\frac 1 {|G|} |\{(g,x)|gx=x\}|
=\frac 1 {|G|}\sum_{g \in G}|\chi(g)|
$$

定理(Polya):

若方案集$X$为对集合$S$上每个元素染成$k$种颜色之一，则$X$在$G$作用下的本质不同方案数为

$$
\frac 1{|G|}\sum_{g \in G}k^{c(g)}
$$

其中$c(g)$为$g$的置换表示的循环个数，如置换(132)(54)(6)(78)的循环个数为4。

## 初等对称多项式

对于变量集$X=\{x_1, x_2, ... , x_m\}$，其上的$n$阶初等对称多项式$\sigma_n$被定义为

$$\sigma_n= \sum_{|S|=n,S\subseteq X}{\prod_{x_i \in S}x_i}$$

特别的，恒有$\sigma_0=1$。

即

$$\sigma_1=x_1+x_2+...+x_n$$

$$\sigma_2=x_1x_2+x_1x_3+...+x_{n-1}x_n$$

$$...$$

$$\sigma_{m}=x_1x_2...x_m$$

向$X$中加入元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1+x'=\sigma_1+\sigma_0x'$$

$$\sigma_2'=\sigma_2+x_1x'+x_2x'+...+x_mx'=\sigma_2+\sigma_1x'$$

$$...$$

$$\sigma_k'=\sigma_k+\sigma_{k-1}x'$$

从$X$中删去元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1-\sigma_0'x'$$

$$\sigma_2'=\sigma_2-\sigma_1'x'$$

$$...$$

$$\sigma_k'=\sigma_k-\sigma_{k-1}'x'$$

由定义易得对称多项式的OGF：

$$F(x)=\prod_{x_i \in X}(1+x_ix)$$

若设

$$s_n=\sum_{x \in X}{x^n}$$

则存在恒等式（牛顿公式）：

$$\sigma_k=\frac{(-1)^{k-1}}{k}\sum_{i=0}^{k-1}{(-1)^i\sigma_is_{k-i}}$$

以下如无特别说明请默认$f(x)=\sum_{i=0}^{n-1}a_ix^i,g(x)=\sum_{i=0}^{m-1}b_ix^i$

## 多项式操作

有关的前置声明和预处理

```cpp
inline int add(int a, int b) { int r = a + b; return r < P ? r : r - P; }
inline int sub(int a, int b) { int r = a - b; return r < 0 ? r + P : r; }
inline int mul(ll a, ll b) { ll r = a * b; return r % P; }
inline int inv(int a) { return a == 1 ? a : mul(inv(P % a), P - P / a); }
inline int qpm(int a, int b) {
    int r = 1;
    do if (b & 1) r = mul(r, a);
    while (a = mul(a, a), b >>= 1);
    return r;
}

ll invs[N], f[N], fi[N];
ll binom(ll n, ll k) { return mul(f[n], mul(fi[n - k], fi[k])); }
void ginv() {
    invs[1] = 1; f[0] = fi[0] = 1;
    for (int i = 2; i != N; ++i) invs[i] = mul(invs[P % i], (P - P / i));
    for (int i = 1; i != N; ++i) f[i] = mul(f[i - 1], i);
    for (int i = 1; i != N; ++i) fi[i] = mul(fi[i - 1], invs[i]);
}

vector<int> add(const vector<int>& p1, const vector<int>& p2) {
    int n3 = max(p1.size(), p2.size());
    vector<int> pr = p1; pr.resize(n3, 0);
    for (int i = 0; i != p2.size(); ++i) pr[i] = add(pr[i], p2[i]);
    return pr;
}

vector<int> sub(const vector<int>& p1, const vector<int>& p2) {
    int n3 = max(p1.size(), p2.size());
    vector<int> pr = p1; pr.resize(n3, 0);
    for (int i = 0; i != p2.size(); ++i) pr[i] = sub(pr[i], p2[i]);
    return pr;
}

vector<int> mul(const vector<int>& p1, ll k) {
    int n1 = p1.size(); vector<int> p2(n1);
    for (int i = 0; i != n1; ++i) p2[i] = mul(k, p1[i]);
    return p2;
}
```

OGF，EGF互转（每项除阶乘和乘阶乘）

```cpp
vector<int> egf(const vector<int>& g) {
    vector<int> r(g.size());
    for (int i = 0; i != g.size(); ++i)
        r[i] = mul(g[i], fi[i]);
    return r;
}

vector<int> iegf(const vector<int>& g) {
    vector<int> r(g.size());
    for (int i = 0; i != g.size(); ++i)
        r[i] = mul(g[i], f[i]);
    return r;
}
```

### 快速卷积原理

给定$f(x),g(x)$，计算$h(x)=f(x)g(x)$。

因为一个$n-1$次多项式的系数可以被其在$n$个不同位置上的取值唯一确定（考虑对其在$n$个位置上的取值列一个$n$元线性方程组，其系数矩阵即为范德蒙德矩阵，因范德蒙德行列式不为0当且仅当$x_i$两两不同，所以该方程组有唯一解），所以如果对于一个$n-1$次多项式我们能够快速求出$f(x)$在$n$个不同位置上的取值并根据其反推原多项式的系数，卷积即可快速完成。

### 快速傅里叶变换

快速傅里叶变换可在$O(n \log n)$内从$n-1$次多项式的$n$个系数推出多项式在$n$个不同位置的取值。

设$\omega_n$满足$\omega_n^{n}=1$且$\forall i \in \{ 1, 2, ..., n - 1\}$，$\omega_n^i \neq 1$，我们选取的位置即为$x=\omega_n^{i},i\in\{0,1,...,n-1\}$。

考虑利用单位根$\omega_n$分治对系数序列进行变换，即求出$f(\omega_n^k)，k\in \{0,1,...,n-1\}$，这里设$n=2^w$。

将序列按下标的奇偶分成两份，即

$$f_0(x)=\sum_{i=0}^{\frac n2-1} a_{2i}x^{i}$$

$$f_1(x)=\sum_{i=0}^{\frac n2-1}a_{2i+1}x^i$$

对每份分别进行FFT可得$f_0(\omega_{\frac n2}^{k}),f_1(\omega_{\frac n2}^{k}),k \in \{0,1,...,\frac n2-1\}$。

注：对$f_0$和$f_1$进行FFT时所用的单位根为$\omega_{\frac n2}=\omega_n^{2}$，即分治下去所得结果为$f_0,f_1$在$\omega_n^{2k},k\in\{0,1,...,\frac n2 -1\}$上的取值。

$$f(\omega_n^k)=\sum_{i=0}^{n-1}a_i \omega_n^{ki}=\sum_{i=0}^{\frac n2-1}a_{2i} \omega_n^{2ki}+\sum_{i=0}^{\frac n2-1}a_{2i+1}\omega_n^{2ki+k}$$

$$=\sum_{i=0}^{\frac n2-1}a_{2i} \omega_n^{2ki}+\omega_n^k\sum_{i=0}^{\frac n2-1}a_{2i+1}\omega_n^{2ki}=f_0(\omega_n^{2k})+\omega_n^kf_1(\omega_n^{2k})$$

$$f(\omega_n^{k+\frac n2})=f(-\omega_n^k)=\sum_{i=0}^{n-1}a_i(-\omega_n^{k})^i=\sum_{i=0}^{\frac n2 - 1}a_{2i}(-\omega_n^k)^{2i}+\sum_{i=0}^{\frac n2 - 1} a_{2i+1}(-\omega_n^{k})^{2i+1}$$

$$=\sum_{i=0}^{\frac n2 - 1}a_{2i}\omega_n^{2ki}-\omega_n^k\sum_{i=0}^{\frac n2 - 1}a_{2i+1}\omega_n^{2ki}=f_0(\omega_n^{2k})-\omega_n^{k}f_1(\omega_n^{2k})$$

注：上述过程的$k \in \{0,1,...,\frac n2 -1\}$

于是每层分治可以在$O(n)$复杂度内合并，总复杂度$O(n \log n)$。

### 快速傅里叶逆变换

快速傅里叶逆变换可在$O(n \log n)$内从多项式在$n$个不同位置的取值推出多项式的$n$个系数。

考虑对$f$利用单位根$\omega_n$进行FFT得到$g$，再对$g$利用单位根$\omega_n^{-1}$进行FFT得到$h$，并设$g,h$的系数分别为$\{b_j\},\{c_k\}$

$$b_j=\sum_{i=0}^{n-1}a_i\omega_n^{ij}$$

$$
c_k=\sum_{j=0}^{n-1}b_j\omega_n^{-j}=\sum_{j=0}^{n-1}\left(\sum_{i=0}^{n-1}a_i\omega_n^{ij}\right)\omega_n^{-jk}=\sum_{i=0}^{n-1}a_i\sum_{j=0}^{n-1}\omega_n^{ij}\omega_n^{-jk}
=\sum_{i=0}^{n-1}a_i\sum_{j=0}^{n-1}\omega_n^{(i-k)j}
$$

注意到当$i=k$时有

$$
\sum_{j=0}^{n-1}\omega_n^{(i-k)j}=\sum_{j=0}^{n-1}1^j=n
$$

当$i \neq k$时有

$$
\sum_{j=0}^{n-1}\omega_n^{(i-k)j}=\frac{1-\omega_n^{(i-k)n}}{1-\omega_n^{i-k}}=\frac{1-1}{1-\omega_n^{i-k}}=0
$$

所以$c_k=na_k$

### 快速数论变换

在一般的FFT中，取$\omega_n=\cos \frac {2 \pi}{n}+i \sin \frac {2 \pi}{n}$并在复数域上进行运算即可。在系数较大时会产生精度问题，但使用`long double`可大幅度提升精度与TLE风险。

有时我们面对的问题是模素数意义下的，这时我们可以考虑直接在模素数有限域下解决快速傅里叶变换的问题。对于素数$p=2^k r+1$，模$p$域乘法群为$p-1$次循环群$Z_{p-1}$，且有子群$Z_{2^k}=\{g^{ri}|i \in \{0,1,...,2^k-1\}\}$，其生成元的阶为$2^k$，于是我们可取$\omega_n=g^r$这里$g$为模$p$意义下的原根。因此对于素数$p=2^kr+1$，我们可在模$p$意义下进行长度为$2^k$或其因子的FFT。

```cpp
const int W = 19, S = 1 << W, g = 3;
int fr[W][S], fw[2][S];

void init() {
    for (int s = 1; s != W; ++s)
        for (int i = 0; i != (1 << s); ++i)
            fr[s][i] = (fr[s][i>>1]>>1)|((i&1)<<(s-1));
    fw[0][0] = fw[1][0] = 1;
    fw[0][1] = qpm(g, (P - 1) / (1 << W));
    fw[1][1] = inv(fw[0][1]);
    for (int i = 2; i != (1 << W); ++i) {
        fw[0][i] = mul(fw[0][i - 1], fw[0][1]);
        fw[1][i] = mul(fw[1][i - 1], fw[1][1]);
    }
}

int fs, ft;
void init(int n) {
    for (fs = 1, ft = 0; fs < n; fs <<= 1, ++ft);
}

void ntt(int* p, int t) {
    for (int i=0;i!=fs;++i) if (i<fr[ft][i]) swap(p[i],p[fr[ft][i]]);
    for (int i = 1, s = 0; i != fs; i <<= 1, s++)
        for (int j = 0; j != fs; j += (i << 1))
            for (int k = 0; k != i; ++k) {
                int u=p[j+k],v=mul(fw[t][k<<(W-s-1)],p[i+j+k]);
                p[j+k] = add(u, v), p[i+j+k] = sub(u, v);
            }
    for (int i=0,x=inv(fs);t&&i!=fs;++i) p[i]=mul(p[i],x);
}
```

### 任意模数NTT

9次普通NTT，巨大常数，$O(n \log n)$

碰到了建议重新思考生成函数之外的做法或弃题（认真）。

```cpp

//  大数模乘
//  允许使用__int128时
typedef unsigned long long ull;
ull mul(ull a, ull b, ull p) {
    return ((__int128)a * b) % p;
}

//  不允许使用__int128时
typedef unsigned long long ull;
typedef long double ld;
ull mul(ull a, ull b, ull p) {
    ll res = a * b - p * (ull)((ld)a * (ld)b / (ld)p);
    return res + p * (res < 0) - p * (res >= (ll)p);
}


void ntt(ll* a, int f, ll q) {
    static const ll g = 3;
    for (int i = 0; i != fs; ++i) if (i < fr[i]) swap(a[i], a[fr[i]]);
    for (int i = 1; i != fs; i <<= 1) {
        ll e = (q - 1) / (i << 1), w0 = qpm(g, f == 1 ? e : q - 1 - e, q);
        for (int j = 0; j != fs; j += (i << 1)) {
            ll w = 1;
            for (int k = 0; k != i; k++, w = w * w0 % q) {
                ll u = a[j + k], v = w * a[i + j + k] % q;
                a[j + k] = (u + v) % q; a[i + j + k] = (u - v + q) % q;
            }
        }
    }
    if (f == -1) {
        ll d = inv(fs, q);
        for (ll i = 0; i != fs; ++i)
            a[i] = a[i] * d % q;
    }
}

vector<int> mul(const vector<int>& p1, const vector<int>& p2, int n = 0) {
    ll q[4] = { 469762049, 998244353, 1004535809 }; q[3] = q[0] * q[1];
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    init(n3 + 1); vector<int> pr(n3);
    for (int j = 0; j != 3; ++j) {
        copy_n(p1.begin(), n1, pa); fill(pa + n1, pa + fs, 0);
        copy_n(p2.begin(), n2, pb); fill(pb + n2, pb + fs, 0);
        ntt(pa, 1, q[j]); ntt(pb, 1, q[j]);
        for (int i = 0; i != fs; ++i) pd[j][i] = pa[i] * pb[i] % q[j];
        ntt(pd[j], -1, q[j]);
    }
    ll i1 = inv(q[1] % q[0], q[0]), i2 = inv(q[0] % q[1], q[1]),
             i3 = inv(q[3] % q[2], q[2]);
    for (int i = 0; i != n3; ++i) {
        ll A = (::mul(pd[0][i] * q[1] % q[3], i1, q[3])
              + ::mul(pd[1][i] * q[0] % q[3], i2, q[3])) % q[3];
        ll k = (((pd[2][i] - A) % q[2] + q[2]) % q[2]) * i3 % q[2];
        pr[i] = M(M(M(k) * M(q[3])) + M(A));
    }
    if (n) pr.resize(n, 0);
    return pr;
}

```

### 卷积

给定$f(x),g(x)$，求$h(x)=f(x)g(x)$。

对$f(x)$与$g(x)$分别进行FFT/NTT，计算逐点乘积后进行逆变换即可。

在$n$小的时候暴力计算可减小常数。

```cpp
int pa[N], pb[N], pc[N], pd[3][N];
vector<int> mul0(const vector<int>& p1, const vector<int>& p2) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    vector<int> p3(n3);
    for (int i = 0; i != n1; ++i)
        for (int j = 0; j != n2; ++j)
            p3[i + j] = add(p3[i + j], mul(p1[i], p2[j]));
    return p3;
}

vector<int> mul(const vector<int>& p1, const vector<int>& p2, int n = 0) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    vector<int> pr(n3);
    if (n3 > 150) {
        init(n3 + 1);
        copy_n(p1.begin(), n1, pa); fill(pa + n1, pa + fs, 0);
        copy_n(p2.begin(), n2, pb); fill(pb + n2, pb + fs, 0);
        ntt(pa, 0); ntt(pb, 0);
        for (int i = 0; i != fs; ++i) pc[i] = mul(pa[i], pb[i]);
        ntt(pc, 1); copy(pc, pc + n3, pr.begin());
    }
    else pr = mul0(p1, p2);
    if (n && pr.size() > n) pr.resize(n, 0);
    return pr;
}
```

### 缩放

给定$f(x)$，求$g(x)=f(kx)$

$$g(x)=f(kx)=\sum_{i=0}^{n-1}{a_ik^ix^i}$$

```cpp
vector<int> scale(const vector<int>& a, ll d) {
    vector<int> b = a;
    for (int i = 0; i != b.size(); ++i)
        b[i] = mul(b[i], qpm(d, i));
    return b;
}
```

### 平移

给定$f(x)$，求$g(x)=f(x+\delta)$。

$$
f(x+\delta)=\sum_{i=0}^{n-1}{a_i\sum_{j=0}^i{\binom ij x^j \delta^{i-j}}}
=\sum_{j=0}^{n-1} x^j \sum_{i=j}^{n-1}{\binom ij a_i \delta^{i-j}}
$$

$$
=\sum_{j=0}^{n-1} x^j \sum_{i=0}^{n-j-1} \binom {n-i-1}{j}a_{n-i-1}\delta^{n-i-j-1}
=\sum_{j=0}^{n-1} x^{n-j-1} \sum_{i=0}^{j} \binom {n-i-1}{n-j-1} a_{n-i-1}\delta^{j-i}
$$

令$c_i=a_{n-i-1}(n-i-1)!$，$d_i=\frac{\delta^i}{i!}$

$$
=\sum_{j=0}^n \frac{x^{n-j}}{(n-j)!}\sum_{i=0}^j \frac{(n-i)!}{(j-i)!}a_{n-i} \delta^{j-i}
=\sum_{j=0}^n\frac{x^{n-j}}{(n-j)!}\sum_{i=0}^j c_i d_{j-i}
$$

将序列c与序列d卷起来再乘以阶乘即可。

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> shift(const vector<int>& a, ll d) {
    int n = a.size();
    vector<int> b = a, c(n);
    reverse(b.begin(), b.end());
    for (int i = 0; i != n; ++i) {
        b[i] = mul(b[i], f[n - i - 1]);
        if (!i) c[i] = 1;
        else c[i] = mul(c[i - 1], mul(d, invs[i]));
    }
    vector<int> r = mul(b, c, n);
    reverse(r.begin(), r.end());
    return egf(r);
}
```

### 求导

给定$f(x)$，求$g(x)=f'(x)$。

$$g(x)=\sum_{i=0}^{n-2}(i+1)a_{i+1}x^i$$

时间复杂度$O(n)$。

```cpp
vector<int> deriv(const vector<int>& p1) {
    int n1 = p1.size();
    vector<int> p2(n1 - 1);
    for (int i = 1; i != n1; ++i) p2[i - 1] = mul(i, p1[i]);
    return p2;
}
```

### 积分

给定$f(x)=\sum_{i=0}^{n-1}{a_ix^i}$，求$g(x)=\int_0^x{f(t)}dt$。

$$g(x)=\sum_{i=1}^{n}{\frac{a_{i-1}}{i}x^i}$$

时间复杂度$O(n)$。

```cpp
vector<int> integ(const vector<int>& p1) {
    int n1 = p1.size();
    vector<int> p2(n1 + 1, 0);
    for (int i = 0; i != n1; ++i) p2[i + 1] = mul(p1[i], invs[i + 1]);
    return p2;
}
```

### 牛顿迭代

注：以下涉及到牛顿迭代过程中的$\frac n2$均自动向上取整。

给定多项式$t(g)$，求$g(x)$使得$t(g) \equiv 0 \mod x^n$。

设已求出$h(x)$使得$t(h) \equiv 0 \mod x^\frac n2$。

因为有$t(g) \equiv 0 \mod x^n$，所以有$t(g) \equiv 0 \mod x^\frac n2$，因此$g(x) \equiv h(x) \mod x^\frac n2$。

考虑$t(g)$在$h$处的泰勒展开

$$t(g) \equiv \sum_{k=0}^\infty \frac {t^{(k)}(h)}{k!}(g-h)^k \mod x^n$$

因为$g(x)-h(x) \equiv 0 \mod x^ \frac n2$，所以第二项往后的项全部为0，我们得到

$$
0 \equiv t(g) \equiv t(h)+t'(h)(g-h) \mod x^n
$$

解得

$$
g \equiv h- \frac{t(h)}{t'(h)} \mod x^n
$$

边界：当$n=1$时根据具体情况处理。

涉及到牛顿迭代的多项式算法基本都自带巨大常数，可能$n \log n$跑$n=10^5$都要一秒左右。

### 求逆

前置：卷积

给定$f(x)$，求$g(x)$使得$f(x)g(x) \equiv 1 \mod x^{n}$。

考虑牛顿迭代：设$t(g)=\frac 1g-f$，则迭代方程为

$$
g(x) = h(x)-\frac{\frac{1}{h(x)}-f(x)}{-\frac{1}{h^2(x)}}=2h(x)-h^2(x)f(x) \mod x^n
$$

边界：当$n=1$时直接求常数的乘法逆即可。

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> inv(const vector<int>& p1) {
    int n1 = p1.size(), n2 = (n1 + 1) >> 1;
    if (n1 == 1) return { ::inv(p1[0]) };
    vector<int> p2 = inv(vector<int>(p1.begin(), p1.begin() + n2));
    init(n1 << 1);
    copy_n(p1.begin(), n1, pa); fill(pa + n1, pa + fs, 0);
    copy_n(p2.begin(), n2, pb); fill(pb + n2, pb + fs, 0);
    ntt(pa, 0); ntt(pb, 0);
    for (int i = 0; i != fs; ++i)
        pc[i] = mul(sub(2, mul(pa[i], pb[i])), pb[i]);
    ntt(pc, 1);
    vector<int> r(n1);
    copy(pc, pc + n1, r.begin());
    return r;
}
```

### 除法与取模

前置：卷积，求逆

给定$f(x)$与$g(x)$，求$q(x)$与$r(x)$使得$f(x)=q(x)g(x)+r(x)$。

其中$q(x)$为$n-m+1$次多项式，$r(x)$为$m-1$次多项式。

考虑将$f(x)$的系数前后翻转

$$f_R(x)=x^{n-1}f(\frac 1x)=\sum_{i=0}^{n-1}a_ix^{n-i-1}$$

将$\frac 1x$作为参数带入上式并两边乘上$x^{n-1}$可得

$$x^{n-1}f(\frac 1x)=x^{n-m+1}q(\frac 1x) x^{m-1}g(\frac 1x)+x^{n-m+1} x^{m-1} r(\frac 1x)$$

$$f_R(x)=q_R(x)g_R(x)+x^{n-m+1}r_R(x)$$

$$f_R(x)=q_R(x)g_R(x) \mod x^{n-m+1}$$

$$q_R(x)=f_R(x)g_R^{-1}(x) \mod x^{n-m+1}$$

对$g_R$多项式求逆后卷上$f_R(x)$并抛掉多余系数即可得到$q_R(x)$，进一步可求出$r_R(x)$。

时间复杂度$O(n \log n)$，大常数。

```cpp

pair<vector<int>, vector<int>> div(const vector<int>& p1, const vector<int>& p2) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 - n2 + 1;
    if (n3 <= 0) return { { 0 }, p1 };
    vector<int> p1r = p1, p2r = p2;
    reverse(p1r.begin(), p1r.end());
    reverse(p2r.begin(), p2r.end());
    p1r.resize(n3, 0); p2r.resize(n3, 0);
    vector<int> p3 = mul(p1r, inv(p2r), n3);
    reverse(p3.begin(), p3.end());
    vector<int> p4 = sub(p1, mul(p2, p3));
    p4.resize(n2 - 1, 0);
    return { p3, p4 };
}
```

注：`first`是$q(x)$，`second`是$r(x)$。

### 开根号

前置：卷积，求逆

给定$f(x)$，求$g(x)$使得$g(x)^2 \equiv f(x) \mod x^{n}$。

考虑牛顿迭代：设$t(g)=g^2-f$，则迭代方程为

$$
g(x)=h(x)-\frac{h^2(x)-f(x)}{2h(x)}=\frac{h^2(x)+f(x)}{2h(x)} \mod x^n
$$

边界：当$n=1$时直接求常数的模意义下二次剩余即可。

时间复杂度$O(n \log n)$，大常数。

```cpp
int msqrt(int n) {
    if (!n) return 0;
    int q = P - 1, s = 0, z = 2;
    //while (~q & 1) q >>= 1, s++;
    q >>= (s = __builtin_ctzll(q));
    if (s == 1) return qpm(n, (P + 1) / 4);
    while(qpm(z, (P - 1) / 2) == 1) ++z;
    int c = qpm(z, q), t = qpm(n, q),
       r = qpm(n, (q + 1) / 2), m = s;
    while(t % P != 1) {
        ll i = 1; while(qpm(t, 1ll << i) != 1) ++i;
        ll b = qpm(c, 1ll << (m - i - 1));
        r = mul(r, b); c = mul(b, b);
        t = mul(t, c); m = i;
    }
    return min(r, P - r);
}

vector<int> sqrt(const vector<int>& p1) {
    int n1 = p1.size(), n2 = (n1 + 1) >> 1;
    if (n1 == 1) return { ::msqrt(p1[0]) };
    vector<int> p2 = sqrt({p1.begin(), p1.begin() + n2});
    vector<int> p3 = mul(p2, 2); p3.resize(n1);
    p3 = inv(p3);
    return mul(add(mul(p2, p2, n1), p1), p3, n1);
}
```

### 对数

前置：卷积，求逆，求导，积分

给定$f(x)$，求$g(x)=\ln f(x)$。

$$g(x)=\ln f(x)=\int_0^{x}\frac{f'(t)}{f(t)}dt$$

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> log(const vector<int>& p1) {
    return integ(mul(deriv(p1), inv(p1), p1.size() - 1));
}
```

### 指数

前置：卷积，对数

给定$f(x)$，求$g(x)=\exp f(x) \mod x^n$。其中$f(0)=a_0=0$。

考虑牛顿迭代：设$t(g)=\ln g-f$，则迭代方程为

$$
g(x)=h(x)-\frac{\ln h-x}{\frac{1}{h}}=h(x)(1- \ln h+f) \mod x^n
$$

边界：当$n=1$时返回常数1。

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> exp(const vector<int>& p1) {
    if (p1.size() == 1) return { 1 };
    vector<int> p2 = exp({p1.begin(),p1.begin()+(p1.size()+1>>1)});
    p2.resize(p1.size(), 0);
    return mul(p2, add(sub({ 1 }, log(p2)), p1), p1.size());
}
```

### 快速幂

前置：对数，指数

给定$f(x)$，求$g(x)=f(x)^k$。

注意到$g(x)=f(x)^k=\exp \ln f(x)^k=\exp k \ln f(x)$，因此快速幂可在$O(n \log n)$内完成。

若$a_0 \neq 1$，则在取对数前需进行如下特判：

若$a_i, i \in \{0, 1, ..., j - 1\}$均为$0$，则可除以一个$x^j$后将$g$像后移$nj$位。

若进行上一步后仍有$a_0 \neq 1$，则将整个序列除以$a_0$，后将整个序列乘以$a_0^k$。

若$nk$较小则在NTT后直接对点值表示快速幂再逆NTT即可(CF1096G)。

时间复杂度$O(n \log n)$，巨大常数。

```cpp
vector<int> pow(const vector<int>& p1, int k) {
    int n1 = p1.size(), n2 = n1;
    while (n2 && !p1[n1 - n2]) n2--;
    int n3 = max(n1 - 1ll * (n1 - n2) * k, 0ll);
    if (!n2 || !n3) return vector<int>(n1, 0);
    vector<int> p2(p1.begin() + n1 - n2, p1.begin() + n1 - n2 + n3);
    ll c = p2[0]; p2 = mul(exp(mul(log(mul(p2, ::inv(c))), k)), qpm(c, k));
    p2.resize(n1, 0); rotate(p2.begin(), p2.begin() + n3, p2.end());
    return p2;
}
```

### 多点求值

给定$f(x)$，和$x_i, i \in \{1, 2, ..., m\}$，求$f(x_i), i \in \{1,2,...,m\}$

构造多项式$g(x)=\prod_{i=1}^m(x-x_i)$，注意到$g(x_i)=0$，考虑多项式除法

$$f(x_i)=q(x_i)g(x_i)+r(x_i)=r(x_i)$$

对$g$取模后只需对$r$求值即可。

$g_{l,r}=\prod_{i=l}^{r}(x-x_i)$可分治求出，将中间结果保存至线段树上后再进行分治，即将对$f$求其在$x_i,i \in \{l,...,r\}$上的值分治为求$f \mod g_{l,mid-1}$在$x_i,i \in \{l,...,mid-1\}$上的值和求$f \mod g_{mid,r}$在$x_i,i \in \{mid,...,r\}$上的值。因NTT常数巨大，所以在分治到一定程度时直接转秦九韶暴力求值可降低常数。

时间复杂度$O(n \log^2 n)$，巨巨巨大常数。

```cpp
vector<int> est[N];

//  秦九韶暴力
int eval(const vector<int>& p, int x) {
    int r = 0;
    for (int i = (int)p.size() - 1; i >= 0; --i)
        r = add(p[i], mul(r, x));
    return r;
}
//  把g分治过程的中间结果存在线段树上
void eval0(const vector<int>& x, int p, int lb, int rb) {
    if (lb + 1 == rb) est[p] = { sub(0, x[lb]), 1 };
    else {
        int mid = (lb + rb) >> 1;
        eval0(x, p << 1, lb, mid);
        eval0(x, p << 1 | 1, mid, rb);
        est[p] = mul(est[p << 1], est[p << 1 | 1]);
    }
}

void eval1(const vector<int>& r, const vector<int>& x,
            int p, int lb, int rb) {
    vector<int> w = div(r, est[p]).second;
    if (lb + 100 >= rb)
        for (int i = lb; i != rb; ++i)
            est[0][i] = eval(w, x[i]);
    else {
        int mid = (lb + rb) >> 1;
        eval1(w, x, p << 1, lb, mid);
        eval1(w, x, p << 1 | 1, mid, rb);
    }
}

vector<int> eval(const vector<int>& p, const vector<int>& x) {
    eval0(x, 1, 0, x.size());
    est[0].resize(x.size());
    eval1(p, x, 1, 0, x.size());
    return est[0];
}
```

## 多项式应用

具体原理见组合.pdf。

### 第一类斯特林数（行）

前置：平移，卷积。

行的OGF：

$$s_n(x)=xs_{n-1}(x)+ns_{n-1}=(x+n)s_{n-1}(x)=\prod_{i=0}^{n}{(x+i)}$$

令$m = \left\lfloor\frac n2\right\rfloor$

当$n \mod 2 \equiv 0$时

$$s_n=s_m(x)s_m(x+m)$$

当$n \mod 2 \equiv 1$时

$$s_n=(x+n)s_m(x)s_m(x+m)$$

倍增下去，每层卷一次即可。

时间复杂度$O(n \log n)$。

```cpp
vector<int> stirling1_row0(int l, int r) {
    if (l == r) return { l, 1 };
    else {
        int n = r - l + 1, n1 = n / 2, n2 = n - n1;
        vector<int> a = stirling1_row0(l, l + n1 - 1);
        vector<int> b = shift(a, n1);
        vector<int> res = mul(a, b);
        if (n1 == n2) return res;
        vector<int> tmp(n + 1);
        copy(res.begin(), res.end(), tmp.begin() + 1);
        return add(mul(res, r), tmp);
    }
}

vector<int> stirling1_row(int n) {
    return stirling1_row0(0, n - 1);
}
```

### 第一类斯特林数（列）

前置：快速幂

$$s_m(x)=\frac{\left(-\ln(1-x)\right)^m}{m!}$$

时间复杂度$O(n \log n)$，巨大常数。

```cpp
vector<int> stirling1_col(int n, int m) {
    vector<int> a(n + 1, 0);
    for (int i = 1; i <= n; ++i) a[i] = invs[i];
    return iegf(mul(pow(a, m), fi[m]));
}
```

### 第二类斯特林数（行）

前置：卷积

$$S_n(x)=\sum_{k=0}^{n}{\frac {x^k}{k!}\sum_{i=0}^k{(-1)^{i}\binom ki (k-i)^n}}=\sum_{k=0}^{n}{x^k\left(\sum_{i=0}^{k}{\frac{(-1)^{i}}{i!}\frac{(k-i)^n}{(k-i)!}}\right)}$$

时间复杂度$O(n \log n)$。

```cpp
vector<int> stirling2_row(int n) {
    vector<int> a(n + 1, 0), b(n + 1, 0);
    for (int i = 0; i <= n; ++i)
        a[i] = (i & 1 ? sub(0, fi[i]) : add(0, fi[i]));
    for (int i = 0; i <= n; ++i)
        b[i] = mul(qpm(i, n), fi[i]);
    return mul(a, b, n + 1);
}
```

### 第二类斯特林数（列）

前置：卷积，求逆

OGF:$$S_m(x)=\frac{x}{1-mx}S_{m-1}(x)=\frac{x^m}{\prod_{i=1}^{m}{1-ix}}$$

EGF:$$S_m(x)=\frac{(e^x-1)^m}{m!}$$

时间复杂度$O(n \log^2 n)$，常数不大。

```cpp
vector<int> stirling2_col0(int l, int r) {
    if (l == r) return { 1 };
    if (l + 1 == r) return { 1, sub(0, l) };
    else {
        int mid = (l + r) >> 1;
        return mul(stirling2_col0(l, mid)
                 , stirling2_col0(mid, r));
    }
}

vector<int> stirling2_col(int n, int m) {
    if (n < m) return vector<int>(n + 1, 0);
    vector<int> a = stirling2_col0(1, m + 1);
    a.resize(n - m + 1, 0);
    vector<int> b = inv(a); b.resize(n + 1, 0);
    rotate(b.begin(), b.begin() + n + 1 - m, b.end());
    return b;
}
```

### 贝尔数

前置：指数

```cpp
vector<int> bell(int n) {
    vector<int> a(n, 1);
    return iegf(exp(sub(egf(a), {1})));
}
```

### 伯努利数

附赠小常数等幂求和(51nod 1258)

前置：求逆

```cpp
vector<int> bernoulli(int n) {
    vector<int> a(n + 1, 1);
    a = sub(egf(a), { 1 });
    rotate(a.begin(), a.begin() + 1, a.end());
    a.pop_back();
    return iegf(inv(a));
}

ll epsum(const vector<int>& b, ll n, ll k) {
    ll ans = 0; ll w = (n %= P);
    for (int i = 1; i <= k + 1; ++i) {
        ll t = mul(binom(k + 1, k + 1 - i), b[k + 1 - i]);
        if ((k + 1 - i) & 1) ans = sub(ans, mul(w, t));
        else ans = add(ans, mul(w, t));
        w = mul(w, n);
    }
    return mul(ans, invs[k + 1]);
}
```

### 有标号（连通）二分图数量

```cpp
vector<int> colored_bipartite(int n) {
    vector<int> b1(n), b2(n), c;
    int sqrt2 = msqrt(2);
    for (int i = 0; i != n; ++i) {
        b1[i] = qpm(sqrt2, 1ll * i * i);
        b2[i] = inv(b1[i]);
    }
    b1 = iegf(b1); b2 = egf(b2); c = mul(b2, b2, n);
    for (int i = 0; i != n; ++i) c[i] = mul(c[i], b1[i]);
    return c;
}

vector<int> bipartite(int n) {
    return iegf(sqrt(egf(colored_bipartite(n))));
}

vector<int> connected_bipartite(int n) {
    return iegf(mul(log(egf(colored_bipartite(n))),invs[2]));
}
```

## 线性递推

定义：

$$f_n=\sum_{k=1}^m a_kf_{n-k}$$
