#图论
[TOC]
###图的计数
#####带标号联通图计数：
$F(n)$为n个点的联通图个数
$G(n)$为n个点的不联通图个数
$H(n)=2^{n(n-1)/2}$为n个点的图的个数
有$F(n) + G(n) = H(n)$
求$G(n)$通过枚举点1所在连通块的大小，有$G(n) = \sum_{k=1}^{n-1}C_{n-1}^{k-1}F(k)H(n-k)$,初始值$F(1)=G(1)=1$
通过枚举第一个联通块,另有$H(n)= \sum_{k=1}^{n}C_{n-1}^{k-1}F(k)H(n-k)$

#####连通二分图计数
$F[n][m]$为n，m个点的二分图的联通图个数
$G[n][m]$为n，m个点的二分图的不联通图个数
$H[n][m]=2^{nm}$为n，m个点的二分图的图的个数
有$F[n][m] + G[n][m] = H[n][m]$
求$G[n][m]$通过枚举点1所在连通块的大小，有$G[n][m] = \sum_{a=1}^{n}\sum_{b=0}^{m}[a!=n||b!=m]C_{n-1}^{a-1}C_{m}^{b}F[a][b]H[n-a][m-b]$

### 三元环计数
方法一(常数较大):
对于一个边数为$m$的无向图,将点按度数是否大于$\sqrt{m}$分为两类
先枚举度数小的点,然后枚举与该点相连的两条边,由于一个点的度不超过$\sqrt{m}$,所以一条边最多被枚到$\sqrt{m}$次,复杂度$m \sqrt{m}$
再求只包含度数大的点的答案,枚举三个点,由于这种点的数量是$\sqrt{m}$级的,所以复杂度$m \sqrt{m}$
(对点定序，避免重复)

方法二:
对所有边按照两端点的度数定向，度数小的往度数大的走，度数相同则按编号小到大走，这样定向后
可以保证是个有向无环图。
为什么呢，要想定向存在环，则这个环上的点度数必须相同，由于保证了编号从小到大走
所以是不可能存在环的。
这样定向同时还保证了每个点的出度不超过sqrt(n),总复杂度msqrt(n)
```
int deg[maxn];
vector<P> G[maxn];
int vi[maxn];
int X[maxm], Y[maxm], cnt[maxm], pos[maxn];
int main() {
    int  n, m, u, v;
    while(scanf("%d%d", &n, &m) != EOF) {
        for(int i = 1; i <= n; i++) {
            vi[i] = deg[i] = pos[i] = 0;
            G[i].clear();
        }
        for(int i = 0; i < m; i++) {
            scanf("%d%d", &X[i], &Y[i]);
            u = X[i], v = Y[i];
            deg[u]++, deg[v]++;
        }
        for(int i = 0; i < m; i++) {
            cnt[i] = 0;
            if(deg[X[i]] < deg[Y[i]]) G[X[i]].push_back(P(Y[i], i));
            else if(deg[Y[i]] < deg[X[i]]) G[Y[i]].push_back(P(X[i], i));
            else {
                if(X[i] < Y[i]) G[X[i]].push_back(P(Y[i], i));
                else G[Y[i]].push_back(P(X[i], i));
            }
        }
        LL ans = 0;
        for(int i = 0; i < m; i++) {
            u = X[i], v = Y[i];
            for(auto vp : G[u]) pos[vp.first] = vp.second, vi[vp.first] = i + 1;
            for(auto vp : G[v]) {
                int vv = vp.first;
                if(vi[vv] == i + 1) {
                    cnt[i]++;
                    cnt[pos[vv]]++;
                    cnt[vp.second]++;
					//边i,pos[vv],vp.second 构成一个三元环
					//计数已去重
                }
            }
        }
        for(int i = 0; i < m; i++) ans += 1LL * cnt[i] * (cnt[i] - 1) / 2;
        printf("%lld\n", ans);
    }
    return 0;
}
```

#####矩阵树定理
定义图$G$的度数矩阵$D$为：如果$i=j,D_{ij}$等于点$i$度数，有向图为出度，否则为0
邻接矩阵$A$为:$A_{ij}$等于从$i$指向$j$的边的数量，无向图的边等价为双向边
定义矩阵$C=D-A$
图$G$的以点$u$为根的生成树个数为$C$去掉第$u$行第$u$列后的行列式的绝对值
在这种情况下其实是默认为边权为1,实际上边权可以为任何值,将度数替换为边权和之后,那么求出来的值就为生成树的边权的乘积和.
给出的边必选$k$条边：设$f_{i}$为必选$i$条边的方案数,将必选边的度数分别设为$0,1,2,\dots ,k$,求得行列式的值$c_{x}$,那么将得到$k$个形如$\sum_{i=0}x^{i}f_{i}=c_{x}$的方程
联立即方程组,高斯消元即可求得解
给出的边都必选：缩点,将给出边的同一联通块内的点缩成一个点,所有与这个联通块连接的边的权值乘以联通块的点集大小即可

#####BEST定理
求图$G$中以$u$为起点的欧拉回路的个数，定义$T(u)$为以$u$为根的生成树个数，那么答案为$T(u)*deg[u]!*\prod_{i!=u}(deg[i]-1)!$,若存在重边，则除以$\prod D_{ij}!$即可

#### 判断图中是否存在长度为L的路径
当L比较小时，可以对边进行随机染色(范围0到L-1)，然后转换为图上是否存在一条长度为L的路径每种颜色只访问一次，这个可以进行bfs验证
因为长度为L的路径的染色情况只有$L^{L}$种，合法情况为$L!$种，随机次数足够的话成功概率极大


### 2-SAT

对于a和b的限制关系:
如果a和b必须一起选，连有向边a->b,b->a,a'->b',b'->a'
如果a和b最多只能选一个，连有向边a->b',b->a'
如果必须选a，连有向边a'->a
如果a一定不能选，连边a->a'
如果a和b至少要选一个，连边a'->b,b'->a
建边一定要有对称性(u->v) 和 (v'->u')

-------------------------------求字典序最小的解的暴力方法-------------------

算法思想：
1.首先定义我们需要用到的数组，mark数组用来标记某个点是否被选取，对于序列中的一个数我们会拆成
两个点i和i'，所以我们在利用mark数组进行标记
2的时候，采用如下这种标记方法：

mark[i<<1]表示i,而mark[i<<1|1]表示i'

一个用来存本次标记过的点的一个队列s

2.枚举每个点，然后判断当前点拆出的两个点是否已经有其中一个被选取，如果有的话，那么继续枚举下一
个点，如果没有被标记，那么转到操作3

3.如果某一点拆出的两个点都没有被标记，那么我们先尝试标记第一个点，因为如果标记第一个点会导致一
些点必须被标记，所以要进行dfs,然后判断过程中会不会出现矛盾的情况，如果出现了，那么将本次标记的
点全部还原，然后就剩下第二个点一种情况，所以我们查看第二种情况，判断会不会出现，，如果出现矛盾，
那么问题无解，结束算法如果当前成功标记，那么继续像2那样枚举，直至枚举过所有的点算法结束。

4.因为每次dfs的过程会把所有当前点可达的点都进行标记，所以之后每次标记的过程中，因为已经标记的
点，有一个不选的话，那么代表所有的点均不选，且会导致与它同源的那个点一定被选，所以一旦被选中，
不能导致出现有解的情况，那么当前情况一定无解，因为每次做的操作只可能会导致图上的点不变或者整体
颜色反转，所以只需要让新染色的点两种选择即可，因为得到的结果只有两种，而且同时做反转操作与没做
的效果是一样的。

5.因为是按照深搜序做的，所以得到解一定是字典序最小的。


--------------------利用强连通缩点判断2-sat问题是否有解------------------
算法思想：

1.利用强连通缩点得到一个DAG（有向无环图）;

2.然后对于每个强连通分量当中，所有点都是选就一起选，不选就一起不选的，所以如果i和i'同时存在一个
强连通分量里，就一定无解，否则有解

-------------------按照拓扑序求得任意一组解-------------------------------
1.首先依旧要进行强连通缩点，存反图！！！！，我们得到一个DAG

2.然后我们要得到新得到的图中的矛盾关系，也就是i和i'所在的强连通分量是矛盾的。

3.然后我们对DAG进行染色，在拓扑排序的过程中进行染色，如果某个点没有染色，那么染为1(表示选择这个点)，并且将与他矛盾的点染为2（表示不选择这个点），并把染色为2的点能访问到的点都染色为2

```
vector<int> g[maxn * 2];
int pre[maxn * 2],low[maxn * 2],scc[maxn * 2];
int dfs_t,scc_cnt;
stack<int> ST;

// 有向图求强联通
void dfs(int u) {
    pre[u] = low[u] = ++dfs_t;
    ST.push(u);
    for(auto v:g[u]) {
        if(!pre[v]) {
            dfs(v);
            low[u] = min(low[u],low[v]);
        } else if(!scc[v]) {
            low[u] = min(low[u],pre[v]);
        }
    }
    if(low[u] == pre[u]) {
        scc_cnt++;
        while(!ST.empty()) {
            int x = ST.top();
            ST.pop();
            scc[x] = scc_cnt;
            if(x == u) break;
        }
    }
}

vector<int>g2[maxn * 2];
int l[maxn * 2],q[maxn * 2],pc[maxn * 2];
void Shrink_Point(int n) {
    for(int u = 1; u <= n; u++) {
        for(auto v:g[u]) {
            if(scc[u] != scc[v]) {
                g2[scc[v]].push_back(scc[u]);
                l[scc[u]]++;
            }
        }
    }
}

void dfsc(int u) {
    if(pc[u]) return;
    pc[u] = 2;
    for(auto v:g2[u]) dfsc(v);
}
//返回true表示有解
bool find_scc(int n) {
    dfs_t = scc_cnt = 0;
    for(int i = 1; i <= n; i++) {
        if(!pre[i]) dfs(i);
    }
    //i和i+1构成对立关系，在同一强联通分量内则无解
    for(int i = 2;i <= n; i += 2) {
        if(scc[i] == scc[i + 1]) return false;
    }
    Shrink_Point(n);
    int mm = 0;
    for(int i = 1;i <= scc_cnt; i++) {
        if(l[i] == 0) q[mm++] = i;
    }
    for(int i = 0;i < mm; i++) {
        for(auto v:g2[q[i]]) {
            l[v]--;
            if(l[v] == 0) q[mm++] = v;
        }
    }
    //新图中的对立关系
    for(int i = 2;i <= n; i += 2) {
        l[scc[i]] = scc[i + 1];
        l[scc[i + 1]] = scc[i];
    }
    //pc[i]表示缩点后的强联通分量选还是不选，1为选，2为不选
    //可以保证pc[scc[i]]和pc[scc[i+1]]是相反的
    //如果pc[scc[i]]为1表示选择i
    for(int i = 0;i < mm; i++) {
        if(pc[q[i]]) continue;
        pc[q[i]] = 1;
        dfsc(l[q[i]]);
    }
    return true;
}

//线段树优化建图
vector<int> ,f[maxn << 2]；
int fl[maxn << 2], fr[maxn << 2], tot;
void update(int t, int l, int r, int ll, int rr, int x) {
    if(ll <= l && r <= rr) {
        f[t].push_back(x);
        return;
    }
    int mid = (l + r) >> 1;
    if(ll <= mid) update(t << 1, l, mid, ll, rr, x);
    if(rr > mid) update(t << 1 | 1, mid + 1, r, ll, rr, x);
}
int rev(int x) {
    if(x & 1) return x - 1;
    else return x + 1;
}
void add_edge(int x, int y) {
    g[x].push_back(y);
    g[rev(y)].push_back(rev(x));
}
void build(int t, int l, int r) {
    fl[t] = tot++;
    int pre = fl[t];
    for(auto e : f[t]) {
        add_edge(pre << 1, rev(e));
        add_edge(pre << 1, tot << 1);
        add_edge(e, tot << 1);
        pre = tot++;
    }
    fr[t] = pre;
    if(t > 1) add_edge(fr[t >> 1] << 1, fl[t] << 1);
    if(l == r) return;
    int mid = (l + r) >> 1;
    build(t << 1, l, mid);
    build(t << 1 | 1, mid + 1, r);
}
```


###差分约束
```
存在n个变量和m组不等式
每个不等式都是形如xi-xj<=c的形式（若为大于等于，则是求最长路）
那么建有向边 从j到i，边权为c
从起点跑最短路，若存在负边用spfa算法
存在负环则无解、
```

###无根树
```
Prufer数列是无根树的一种数列。在组合数学中，Prufer数列由有一个对于顶点标过号的树转化来的数列，
点数为n的树转化来的Prufer数列长度为n-2，且有度数为i的点在Prufer数列中出现i-1次

一种生成Prufer序列的方法是迭代删点，直到原图仅剩两个点。对于一棵顶点已经经过编号的树T，顶点的编
号为{1,2,...,n}，在第i步时，移去所有叶子节点（度为1的顶点）中标号最小的顶点和相连的边，并把与
它相邻的点的编号加入Prufer序列中，重复以上步骤直到原图仅剩2个顶点。
Cayley公式是说，一个完全图K_n有n^(n-2)棵生成树，换句话说n个节点的带标号的无根树有n^(n-2)个，
即Prufer数列的任意位置可取任意值

一个有趣的推广是，n个节点的度依次为D1, D2, …, Dn的无根树共有
(n-2)! / [ (D1-1)!(D2-1)!..(Dn-1)! ]个，因为此时Prüfer编码中的数字i恰好出现Di-1次
```

###有向图强联通+缩点
#####Kosaraju算法
对原图G进行深度优先遍历，记录dfs序
按dfs序选择起点，对反图GT进行遍历，删除能够遍历到的顶点，这些顶点构成一个强连通分量
如果还有顶点没有删除，继续步骤2，否则算法结束

```
const int maxn = 1e5 + 5;
vector<int> g[maxn];
int pre[maxn],low[maxn],scc[maxn];
int dfs_t,scc_cnt;
stack<int> ST;

// 有向图求强联通
void dfs(int u) {
    pre[u] = low[u] = ++dfs_t;
    ST.push(u);
    for(auto v:g[u]) {
        if(!pre[v]) {
            dfs(v);
            low[u] = min(low[u],low[v]);
        } else if(!scc[v]) {
            low[u] = min(low[u],pre[v]);
        }
    }
    if(low[u] == pre[u]) {
        scc_cnt++;
        while(!ST.empty()) {
            int x = ST.top();
            ST.pop();
            scc[x] = scc_cnt;
            if(x == u) break;
        }
    }
}

vector<int>g2[maxn];
//有向图缩点
void Shrink_Point(int m,int n) {
    for(int i = 1;i <= m; i++) g2[i].clear();
    for(int u = 1; u <= n; u++) {
        for(auto v:g[u]) {
            if(scc[u] != scc[v]) {
                g2[scc[u]].push_back(scc[v]);
            }
        }
    }
}

void find_scc(int n) {
    dfs_t = scc_cnt = 0;
    memset(scc,0,sizeof(scc));
    memset(pre,0,sizeof(pre));
    for(int i = 1; i <= n; i++) {
        if(!pre[i]) dfs(i);
    }
    Shrink_Point(scc_cnt,n);
}
```

###无向图双联通
```
typedef pair<int,int> P;
const int maxn = 1e5 + 5;
vector<int> g[maxn],g_bcc[maxn];
int pre[maxn],low[maxn],bcc[maxn];
bool iscut[maxn];//是否为割点
int dfs_t,bcc_cnt;
stack<P> ST;

// 求无向图点双联通
// 任意两点存在两条以上边不重复的路径称为边双联通
// 任意两点存在两条以上点不重复的路径称为点双联通
// 对于无向图，任意边只属于一个点双联通分量，但点可能属于多个点双联通分量
// g_bcc 保存一个点双联通的点集
void dfs(int u,int fa) {
    pre[u] = low[u] = ++dfs_t;
    int child = 0;
    for(auto v:g[u]) {
        if(!pre[v]) {
            ST.push(P(u,v));
            child++;
            dfs(v,u);
			low[u] = min(low[u], low[v]);
            //if(low[v] > pre[u]) edge(u,v)就是桥
            if(low[v] >= pre[u]) {
                iscut[u] = true;
                g_bcc[++bcc_cnt].clear();
                while(!ST.empty()) {
                    P e = ST.top();
					//当前访问的所有边即是该点双联通分量内的所有边
                    ST.pop();
                    if(bcc[e.first] != bcc_cnt) {
                        g_bcc[bcc_cnt].push_back(e.first);
                        bcc[e.first] = bcc_cnt;
                    }
                    if(bcc[e.second] != bcc_cnt) {
                        g_bcc[bcc_cnt].push_back(e.second);
                        bcc[e.second] = bcc_cnt;
                    }
                    if(e.first == u && e.second == v) break;
                }
            }
        } else if(pre[v] < pre[u] && v != fa) {
            ST.push(P(u,v));
            low[u] = min(low[u],pre[v]);//用反向边更新自己
        }
    }
    if(fa == 0 && child > 1) iscut[u] = 1;
}

void find_bcc(int n) {
	memset(pre, 0, sizeof(pre);
	memset(iscut, 0, sizeof(iscut);
	memset(bcc, 0, sizeof(bcc));
	dfs_t = bcc_cnt = 0;
	for(int i = 1;i <= n; i++) {
		if(!pre[i]) dfs(i, 0);
	}
}

//求边双联通分量
//先dfs求出所有桥，删去桥的联通块即是边联通分量
```

###01分数规划
```
首先01分数规划是处理这样一类问题的，给你n个二元组，这个两个元素设为a[i] ,b[i], a[i]是得到这个物品
所能得到的价值，b[i]是得到这个物品所付出的价值，让你求这样一个极值
    R  =  sigma(a[i] * x[i]) / sigma(b[i] * x[i])求他的最大或最小，这里我们以最大为例说事。
设 F(L) = sigma(a[i] * x[i]) - L * sigma(b[i] * x[i])//注意此时的L和R的关系
    化简  = sigma((a[i] - L * b[i]) * x[i])
    设 d[i] = a[i] - L * b[i]
    则 F(L) = sigma(d[i] * x[i])

    F(L)到底到底有什么用呢？
    我们假设F(L) > 0 则有 sigma(a[i] * x[i]) - L * sigma(b[i] * x[i]) > 0
    转化后得到 sigma(a[i] * x[i]) / sigma(b[i] * x[i]) > L
    也就是说当F(L) > 0 的时候有更大的L，也就是有更大的R，那么只要F(L) > 0我们就可以直接去找更大的L（R）直到F(L) 无限接近0为止，
这里我们可以用二分去查找，理由是F(L) = sigma(d[i] * x[i]) ，d[i] 又是随着L增加而减少的，只要能找到一种
sigma(d[i] * x[i])>=0的情况我们就可以继续往上找，说道这里直接分细化，上面说只要找到一组d[i]>=0的就可以low = mid 往上找了，这里到底有没
有限制呢，当然有，限制就是上面的那三个分类，
（1）正常的情况（没有任何限制的）我们只要找到一个最大的d[i]，d[i]>= 0就行了，因为是只要找到一种情况就行，我们没必要多找，但是前两天见到
一个是限制必须选择n - k个的，那么就把虽有的d[i]求出来，排序，取最大的那n-k个的和，看大是否大于等于0就行了
（2）最优比率生成树，就是在我们选择的时候要找到一颗满足要求的数而已，一般都是求最小树或者最大树，然后看权值是否>=0.
（3）最优比率生成环，就是要求我们选择一个环，令d[i] = L * b[i] - a[i]，就反过来判断负环了，用SPFA,判断满足要求的环
```

###虚树
```
虚树上包含所有关键点和关键点之间所有的lca，虚树的dfs序下(相邻两点的距离和+首尾两点距离)/2为关键点构成一棵树的最小花费


vector<int> g[maxn],g2[maxn];
int depth = 0,bn = 0,b[maxn << 1];
int f[maxn << 1],dfn[maxn],dis[maxn],fs[maxn];
LL ans[maxn];

void dfs(int u,int fa) {
    int tmp = ++depth;
    b[++bn] = tmp;
    f[tmp] = u;
    dfn[u] = bn;
    for (auto v:g[u]) {
        if (v == fa) continue;
        dis[v] = dis[u] + 1;
        dfs(v,u);
        b[++bn] = tmp;
    }
}

int st[maxn << 1][20];
int lg[maxn << 1];
void st_init() {
    for (int i = 2; i < maxn * 2; ++i) lg[i] = lg[i >> 1] + 1;
    for (int i = bn; i >= 1; --i) {
        st[i][0] = b[i];
        for (int j = 1; i + (1 << j) - 1 <= bn; ++j)
            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
    }
}
int rmq(int l, int r) {
    int k = lg[r - l + 1];
    return min(st[l][k], st[r - (1 << k) + 1][k]);
}

int lca(int a,int b) {
    if(a == b) return a;
    if (dfn[a] > dfn[b]) swap(a,b);
    int k = rmq(dfn[a],dfn[b]);
    return f[k];
}

bool cmp(const int &i, const int &j) {
    return dfn[i] < dfn[j];
}
//vec 为需要构建虚树的点集,构造出的虚树树根为0
//原树不包含点0
void build_tree(vector<int> &vec) {
    int sz = 0,k = vec.size();
    sort(vec.begin(),vec.end(),cmp);
    fs[sz] = 0;
    g2[0].clear();
    for (int i = 0; i < k; ++i) {
        int u = vec[i], ll = lca(u, fs[sz]);
        g2[u].clear();
        if (ll == fs[sz]) fs[++sz] = u;
        else {
            while (sz >= 1 && dis[fs[sz - 1]] >= dis[ll]) {
                g2[fs[sz - 1]].push_back(fs[sz]);
                sz--;
            }
            if (fs[sz] != ll) {
                g2[ll].clear();
                g2[ll].push_back(fs[sz--]);
                fs[++sz] = ll;
            }
            fs[++sz] = u;
        }
    }
    for (int i = 0; i < sz; ++i) g2[fs[i]].push_back(fs[i + 1]);
}

int main() {
    dis[1] = 1;
    dfs(1,0);
    st_init();

    build_tree(vec);
    return 0;
}

```

###LCA
```
vector<int> g[maxn],g2[maxn];
int depth = 0,bn = 0,b[maxn << 1];
int f[maxn << 1],dfn[maxn],dis[maxn],fs[maxn];
LL ans[maxn];

void dfs(int u,int fa) {
    int tmp = ++depth;
    b[++bn] = tmp;
    f[tmp] = u;
    dfn[u] = bn;
    for (auto v:g[u]) {
        if (v == fa) continue;
        dis[v] = dis[u] + 1;
        dfs(v,u);
        b[++bn] = tmp;
    }
}

int st[maxn << 1][20];
int lg[maxn << 1];
void st_init() {
    for (int i = 2; i < maxn * 2; ++i) lg[i] = lg[i >> 1] + 1;
    for (int i = bn; i >= 1; --i) {
        st[i][0] = b[i];
        for (int j = 1; i + (1 << j) - 1 <= bn; ++j)
            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
    }
}
int rmq(int l, int r) {
    int k = lg[r - l + 1];
    return min(st[l][k], st[r - (1 << k) + 1][k]);
}

int lca(int a,int b) {
    if(a == b) return a;
    if (dfn[a] > dfn[b]) swap(a,b);
    int k = rmq(dfn[a],dfn[b]);
    return f[k];
}

int main() {
    int u,v,i,m;
    scanf("%d",&n);
    for(i = 1; i < n; i++) {
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    rt = 1;
    dis[rt] = 1;
    dfs(1,0);
    st_init();
}


倍增求lca，复杂度(n+q)logn
可以实现动态加减叶子结点

vector<int> g[maxn];
int d[maxn],st[maxn][18];

void dfs(int u,int fa) {
    for(auto v:g[u]) {
	if(v == fa) continue;
        d[v] = d[u] + 1;
        st[v][0] = u;
        for(int i = 1;i < 18; i++) st[v][i] = st[st[v][i - 1]][i - 1];
        dfs(v,u);
    }
}

int lca(int u,int v) {
    if(d[u] > d[v]) swap(u,v);
    int x = d[v] - d[u];
    for(int i = 0;i < 18; i++) {
        if((x >> i) & 1) v = st[v][i];
    }
    if(u != v) {
        for(int i= 17;i >= 0; i--) {
            if(st[u][i] != st[v][i]) {
                u = st[u][i];
                v = st[v][i];
            }
        }
        u = st[u][0];
    }
    return u;
}
```

###树的重心
```
树的重心的一个的性质：
树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么他们的距离和一样。
这也是“道路修建”带来的启发。（证明：调整法）

树的重心的另一个性质：
把两个树通过一条边相连得到一个新的树，那么新的树的重心在连接原来两个树的重心的路径上。
这个让“重心”名副其实了。。。（证明：。。。自己好好思考一下吧。。。）

还有一个性质：
把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

求重心方法：一遍dfs，维护当前结点的子树大小

h 为重心点
const int maxn = 1e5 + 5;
vector<int> g[maxn];
int son[maxn],h,m,nn;
long long ans;

void dfs1(int u,int fa){
    son[u] = 0;
    int d = 0;
    for(auto v:g[u]){
        if(v == fa) continue;
        dfs1(v,u);
        son[u] += son[v] + 1;
        d = max(d,son[v] + 1);
    }
    d = max(d,nn - son[u] - 1);
    if(d < m){
        m = d;
        h = u;
    }
}
```

###树的直径
从任意一点出发dfs到的最远点为s，从s出发dfs到的最远点为t，则s-t为树的直径

### 最小乘积生成树
图上每条边有$k$个权值,求一棵生成树使得$\prod_{i = 1}^{k}(\sum cost(j,val_{i}))$最小
$k=2$时,定义每条边的权值为$w(x,y)$,每棵生成树定义为二维平面上的点$(s_{x},s_{y})$,先求出$\sum x$最小的生成数$A$和$\sum y$最小的生成数$B$,考虑直线$AB$靠原点一侧距离直线最远的点$C$,求出生成树$C$,$C$在直线$AB$下方当且仅当$(B - A) \times (C - A) > 0$,然后递归直线$AC,CB$,就可以得到生成树的点集组成的凸包的下凸壳,可以证明答案一定是这个凸壳上的点,$check$每个点即可.
求$C$的方法:因为$(B - A) \times (C - A) > 0$,所以展开有$s_{xc}(s_{yb} - s_{ya}) - s_{yc}(s_{xb} - s_{xa}) - A \times B$,所以把每条边的权值定义为$x(s_{yb} - s_{ya}) - y(s_{xb} - s_{xa})$求最小生成树即可.
$k$维的时候类似的,即是求每一维最小的生成树然后递归求一个高维凸壳……

### 次小生成树
先求出最小生成树,预处理出任意两点的路径上的边的边权最大值,然后枚举加边……
稠密图: 对每个点dfs求出u到v的路径上的权值最大的边,枚举边求次小生成树,复杂度$n^{2}$
稀疏图: 枚举边,求出lca,树上倍增求u到lca和v到lca的路径上权值最大的边,复杂度$mlogn$

### 最小度限制生成树
使某个点的度数为$k$的最小生成树
把该点扔掉跑最小生成树,得到$m$个联通块,然后把这些联通块和扔掉的点连起来求个最小生成树,就得到度数为$m$的最小生成树了
然后把这个点定为根,$dp$预处理出所有点到根的路径上的边权最大值,枚举加边,把增值最小的边加进去就可以得到$m+1$度限制生成树了

### Boruvka算法
我们维护图中所有连通块,然后遍历所有的点和边,找到每一个连通块和其他连通块相连的最小的一条边,然后把连通块合并起来,重复这个操作,直到剩下一整个连通块,最开始状态是每个点是一个单独的连通块
复杂度是$(n+m)logn$,因为每次都会合并两个连通块,整个程序进行$log$次操作就会完成,每次操作的复杂度是$n+m$的,利用并查集实现即可

###树分治
```
/*
树被定义为没有圈的连通图.
树的性质:
  1. 在树中去掉一条边后所得的图是不连通的.
  2. 在树中添加一条边后所得的图一定存在圈.
  3. 树的每一对顶点u和v之间有且仅有一条路径.
*/
/*基于点的分治
做法: 首先选取一个点将无根树转为有根树, 再递归处理每一颗以根结点的儿子为根的子树.
选点: 对于基于点的分治, 我们选取一个点, 要求将其删去后, 结点最多的树的结点个数最小, 这个点被称为"树的重心".
定理: 存在一个点使得分出的子树的结点个数均不大于 $\frac{N}{2}$.
*/
/**如何得到答案
1. 容斥: 先求出经过中心u的所有满足条件的答案, 在减去所有子树的答案(不经过点u)
2. 先处理中心一个的情况, 然后先得出该子树与前面子树的答案, 再将该子树的信息存储
*/
vector<int> g[maxn];
int Que[maxn], tail, top;
int sz[maxn], num[maxn];
int fa[maxn];
int vis[maxn], Tt;
int getRoot(int u) { //得到重心
    tail = top = 0;
    Que[top++] = u;
    fa[u] = -1;
    while(tail < top) {
        u = Que[tail++];
        for(auto v:g[u]) {
            if(v == fa[u] || vis[v] == Tt) continue;
            Que[top++] = v;
            fa[v] = u;
        }
    }
    int root = -1;
    while(tail) {
        u = Que[--tail];
        sz[u] = 1, num[u] = 0;
        for(auto v:g[u]) {
            if(v == fa[u] || vis[v] == Tt) continue;
            sz[u] += sz[v];
            num[u] = max(num[u], sz[v]);
        }
        num[u] = max(num[u], top - sz[u]);
        if(root < 0 || num[u] < num[root]) root = u;
    }
    return root;
}

void deal(int u, int pre) { //处理u所属子树
    tail = top = 0;
    Que[top++] = u;
    fa[u] = pre;
    while(tail < top) {
        u = Que[tail++];
        for(auto v:g[u]) {
            if(v == fa[u] || vis[v] == Tt) continue;
            fa[v] = u;
            Que[top++] = v;
        }
    }
    for(int i = 0;i < top; ++i) {
        int u = Que[i];
        //求出答案

    }
}
void solve(int u) {
    u = getRoot(u);
    vis[u] = Tt;
    //处理中心一个点情况和存储信息
    for(auto v:g[u]) {
        if(vis[v] == Tt) continue;
        deal(v, u);
    }
    for(auto v:g[u]) {
        if(vis[v] == Tt) continue;
        solve(v);
    }
}


/*基于边的分治
在树中选取一条边, 将原树分成两棵不相交的树, 递归处理.
选边: 基于边的分治, 我们选取的边要满足所分离出来的两棵子树的结点个数尽量平均, 这条边称为"中心边".
定理: 如果一棵树中每个点的度均不大于 D, 那么存在一条边使得分出的两棵子树的结点个数在 $[ \frac{N}{D -1}, \frac{N D}{D -1 } ] (N \geq 2)$.
(?即树链剖分)
*/
```

###树的最小支配集, 最小点覆盖, 最大独立集
```
/*最小支配集V': 对于图G=(V, E)中的任一顶点u, 要么属于集合V', 要么与V'中的顶点相邻, 且|V'|最小
最小点覆盖V': 对于图G=(V, E)中的任一边<u, v>, 要么u属于V', 要么v属于V', 且|V'|最小.
最大独立集V': 对于图G=(V, E)中取出尽可能多的点使这些点间没有边相连
对任意图G, 无多项式时间解法, 对树有两种解法
*/
/*贪心法 $O(n)$
对树进行深度优先遍历, 反遍历序中:
最小支配集: 对即不属于支配集, 也不与支配集相邻的顶点, 如果父节点不属于支配集, 将其父节点加入支配集
最小点覆盖: 当前结点和其父节点都不属于覆盖集, 将父节点加入覆盖集, 标记当前点和父节点为已覆盖
最大独立集: 当前结点未被覆盖, 把该结点加入独立集, 标记当前点和父节点为已覆盖.
默认根结点的父节点为自己, 最小支配集和最大独立集需检查根结点是否满足贪心条件.
*/

//DFS
int n, m;
int fa[MAXV];
int vis[MAXV];
int dfn[MAXV], now;
void dfs(int u)
{
    dfn[now++] = u;
    for(int i = head[u]; i != -1; i = e[i].next)
        if(!vis[e[i].to])
        {
            vis[e[i].to] = true;
            fa[e[i].to] = u;
            dfs(e[i].to);
        }
}

int greedy()
{
	bool s[MAXV] = {};
	bool res[MAXV] = {};
	int ans = 0;
	for(int i = n - 1; i >= 0; --i)
	{
		int t = dfn[i];
		//最小支配集
		if(!s[t])
		{
			if(!res[p[t]])
			{
				s[p[t]] = true;
				++ans;
			}
			s[t] = true;
			s[p[t]] = true;
			s[p[p[t]]] = true;
		}
		//最小点覆盖
		if(!s[t] && !s[p[t]])
		{
			res[p[t]] = true;
			++ans;
			s[t] = s[p[t]] = true;
		}
		//最大独立集
		if(!s[t])
		{
			res[t] = true;
			++ans;
			s[t] = s[p[t]] = true;
		}
	}
	return ans;
}
//dp $O(n)$
//最小支配集
void DP(int u, int p)
{
	dp[u][2] = 0;
	dp[u][0] = 1;
	bool s = false;
	int sum = 0, inc = INF;
	for(int i = head[u]; ~i; i = e[i].next)
	{
		int v = e[i].to;
		if(v == p) continue;
		DP(v, u);
		dp[u][0] += min(dp[v][0], min(dp[v][1], dp[v][2]));
		if(dp[v][0] <= dp[v][1])
		{
			sum += dp[v][0];
			s = true;
		}
		else
		{
			sum += dp[v][1];
			inc = min(inc, dp[v][0] - dp[v][1]);
		}
		if(dp[v][1] != INF && dp[u][2] != INF)
			dp[u][2] += dp[v][1];
		else
			dp[u][2] = INF;
	}
	if(inc == INF && !s) dp[u][1] = INF;
	else
	{
		dp[u][1] = sum;
		if(!s) dp[u][1] += inc;
	}
}
//最小点覆盖
void DP(int u, int p)
{
	dp[u][0] = 1;
	dp[u][1] = 0;
	for(int i = head[u]; ~i; i = e[i].next)
	{
		v = e[i].to;
		if(v == p) continue;
		DP(v, u);
		dp[u][0] += min(dp[v][0], dp[v][1]);
		dp[u][1] += dp[v][0];
	}
}
//最大独立集
void DP(int u, int p)
{
	dp[u][0] = 1;
	dp[u][1] = 0;
	for(int i = head[u]; ~i; i = e[i].next)
	{
		v = e[i].to;
		if(v == p) continue;
		DP(v, u);
		dp[u][0] += dp[v][1];
		dp[u][1] += max(dp[v][0], dp[v][1]);
	}
}
```


####对于无向图,存在改变边的操作和基于连通性的询问
#####KEY:按秩合并并查集
1.hihocoder1629_Graph
题意: 给你一个带标号的无向图,有q次询问,每次询问区间[L,R]内有多少对点联通并且这对点的路径上所有点都在这个区间内.

按端点从小到大的顺序加边,每条边加两次,然后能得到一个边序列,同时能处理出每个点所属的边的区间[li,ri],对于一个询问[L,R],即询问边序列上区间[lL,rR]内两个端点都在[L,R]内的那些边组成的图的答案.
```
    for(i = 1,m = -1;i <= n; i++) {//加边
        l[i] = m + 1;
        for(auto v:g[i]) {
            if(v > i) p[++m] = P(i,v);
            else p[++m] = P(v,i);
            lim[m] = i;
        }
        r[i] = m;
    }
```
然后把这个边序列分块,用类似莫队的思想处理询问,只是把减操作变成了还原操作,用按秩合并的并查集维护联通块个数即可.

2.Educational Codeforces Round 38 G:Shortest Path Queries
题意:一个带边权的无向图,有加边删边和询问操作,询问(u,v)之间的一条权值最小的路径,权值定义为路径上所有边权异或和,一条边可以经过多次

如果不存在删边操作,可以很容易做
把询问定义为区间,把每条边的出现区间放到线段树上,那么每条边最多被放到了log个区间
然后偏左序的dfs线段树,每到一个线段树的结点就把在该结点记录的边加上,回溯时再删去,用按秩合并并查集即是还原,那么每次dfs到线段树的叶子结点时,叶子结点所表示的该次询问当时出现的所有边都加上去了
并查集维护所有点到根结点的路径的异或和,存在一个环即加值进字典树,询问时在字典树上查询即可


###欧拉回路
定义: 寻找一条回路, 经过且仅经过一次所有边, 最后回到出发点
存在的充要条件: 1. 该图是连通的 2. 无向图, 度数为奇数的顶点的个数为0; 有向图, 每个顶点入度等于出度
构造算法: $O(|E|)$
1. 深度搜索, 得出一条回路.
2. 如果该回路不是欧拉回路, 则沿该回路回溯, 找到一个没有搜索过的顶点, 重复步骤1, 然后将新回路加入答案中.
定义欧拉路径: 寻找一条简单路径, 经且仅经过所有边一次
存在条件: 连通, (无向图)度数为奇数的顶点个数为0或2, (有向图)只有两个顶点入度不等于出度, 且一个入度比出度大1, 另一个小1.
```
#define MAXE
int ans[MAXE], ansi;//ansi等于V表示存在欧拉回路
bool vis[2 * MAXE];
void dfs(int u)
{
    for(int i = head[u]; ~i; i = e[i].next)//链式前向星存储
    {
        if(vis[i]) continue;
        vis[i ^ 1] = vis[i] = true;//标记当前边及反向边
        dfs(e[i].to);
        ans[ansi++] = i;//沿回溯道路将经过的每个点加入答案
    }
}
///有向图欧拉路径
int in[MAX_V], out[MAX_V];//入度和出度
int num;//已经有多少边在欧拉路径中
int pre_edge[MAX_E];//存储每一条边的上一条边
//通过入度和出度判定是否可能存在欧拉路径, 存在返回起点, 否则返回-1
int is_exist_euler()
{
    int sp = -1, tp = -1;
    bool flag = true;
    for(int i = 0; flag && i < V; ++i)
    {
        if(in[i] == out[i]) continue;
        if(in[i] - out[i] == 1)
        {
            if(tp == -1) tp = i;
            else flag = false;
        }
        else if(out[i] - in[i] == 1)
        {
            if(sp == -1) sp = i;
            else flag = false;
        }
        else flag = false;
    }
    if(!flag) return -1;
    if(sp < 0 && tp >= 0) return - 1;
    if(sp >= 0 && tp < 0) return -1;
    if(sp < 0 && tp < 0)
    {
        int i = 0;
        while(sp == -1)
        {
            if(head[i] != -1)
            {
                sp = i;
            }
            i++;
        }
    }
    if(!flag)
        sp = -1;
    return sp;
}
int find_path(int u, int pree)
{
    //寻找以u为起点的一条边
    int i;
    while(head[u] != -1)
    {
        i = head[u];
        pre_edge[i] = pree;//加入改变进欧拉路径
        pree = i;
        head[u] = e[i].next;//将已经访问过的边去掉
        u = e[i].v;//要访问的下一个结点
        num++;
    }
    return pree;//访问当前路径最后一条边
}
//存在欧拉路径返回最后一条边的编号, 否则返回-1
int oula_path()
{
    int st = is_exist_euler();//判断是否可能存在欧拉路径
    if(st == -1) return -1;
    num = 0;
    int ed = find_path(st, -1);//找到基础路径
    int ei = ed;
    while(ei >= 0)
    {
        if(head[e[ei].u] != -1)
        {
            pre_edge[ei] = find_path(e[ei].u, pre_edge[ei]);//寻找环
        }
        ei = pre_edge[ei];
    }
    if(num != E)//可能存在其他连通块
        return -1;
    return ed;
}
```

###哈密顿回路
定义: 寻找一条回路, 经且仅经过每个顶点一次, 最后回到出发点.
存在的充分条件: 任意两个不同顶点的度数和大于等于顶点数V.
构造算法: $O(|V|^2)$
1. 任找两个相邻顶点S, T
2. 分别向两头扩展至无法扩展为止, 称头尾结点为S, T
3. 若S, T不相邻, 在路径$S \to T$中找到结点$V_i$, 其中$V_i$与T相邻, V$_{i+1}$与S相邻, 令$S \to T $变为$S \to V_i \to T \to V_{i+1}$.
4. ($S \to T$已为回路)若$S\to T$中顶点个数不为V, 找$S \to T$中找到顶点$V_i$, 其中$V_i$与一个未访问过得顶点相邻, 从$V_i$处断开(S为$V_i$, T为$V_{i+1}$,重复2.

```
#define MAXV
int V;
int ans[MAXV];
bool G[MAXV][MAXV];//邻接矩阵存储
bool vis[MAXV];

void Hamilton()
{
    int s = 1, t;
    int ansi = 2;
    int i, j;
    memset(vis, false, sizeof(vis));
    for(i = 1; i <= V; i++) if(G[s][i]) break;
    t = i;
    ans[0] = s, ans[1] = t;
    while(1)
    {
        while(1)
        {
            for(i = 1; i <= V; i++)
                if(G[t][i] && !vis[i])
                {
                    ans[ansi++] = i;
                    vis[i] = true;
                    t = i;
                    break;
                }
            if(i > V)break;
        }
        reverse(ans, ans + ansi);
        swap(s, t);
        while(1)
        {
            for(i = 1; i <= V; i++)
                if(G[t][i] && !vis[i])
                {
                    ans[ansi++] = i;
                    vis[i] = true;
                    t = i;
                    break;
                }
            if(i > V)break;
        }
        if(!G[s][t])
        {
            for(i = 1; i < ansi - 2; i++)if(G[s][ans[i + 1]] && G[ans[i]][t]) break;
            t = ans[++i];
            reverse(ans + i, ans + ansi);
        }
        if(ansi == V)return ;
        for(j = 1; j <= V; j++)
            if(!vis[j])
                for(i = 1; i < ansi - 2; i++)if(G[ans[i]][j])break;
        s = ans[i - 1];
        t = j;
        reverse(ans, ans + i);
        reverse(ans + i, ans + ansi);
        ans[ansi++] = j;
        vis[j] = true;
    }
}
```

###最短路
```
//dijkstra算法 $O(|E|\log{|V|})$
struct edge {int next, to, cost;} e[MAXE];
int head[MAXV], tot;
int V, E;//结点数和边数(结点编号开始于1)
void init();
void add_edge(int u, int v, int w);
int dist[MAXV];
void dijstra(int s)
{
    priority_queue<P, vector<P>, greater<P> > que;
    for(int i = 1; i <= V; ++i) dist[i] = INF;
    dist[s] = 0;
    que.push(P(0, s));
    while(!que.empty())
    {
        P p = que.top(); que.pop();
        int u = p.SE;
        if(dist[u] < p.FI) continue;
        for(int i = head[u]; ~i; i = e[i].next)
        {
            if(dist[e[i].to] <= dist[u] + e[i].cost) continue;
            dist[e[i].to] = dist[u] + e[i].cost;
            que.push(P(dist[e[i].to], e[i].to));
        }
    }
}

//dijkstra算法$O(|V|^2)$
int cost[MAXV][MAXV];
int d[MAXV];
bool vis[MAXV];
void dijkstra(int s)
{
    fill(d, d + V, INF);
    memset(vis, 0, sizeof(vis));
    d[s] = 0;
    while(true)
    {
        int v = -1;
        for(int u = 0; u < V; u++)
            if(!vis[u] && (v == -1 || d[u] < d[v]))
                v = u;
        if(v == -1) break;
        for(int u = 0; u < V; u++)
            d[u] = min(d[u], d[v] + cost[v][u]);
    }
}
//Bellman-Ford算法$ O(|E| \cdot |V|)$
//$d[v] = \min{\{d[u] + w[e]\}}(e = <u, v> \in E)$

const int MAXV = 1000, MAXE = 1000, INF = 1000000007;
struct edge {int u, v, cost;} e[MAXE];
int V, E;
//graph G
int d[MAXV];
void Bellman_Ford(int s)
{
    for(int i = 0; i < V; i++)
        d[i] = INF;
    d[s] = 0;
    while(true)
    {
        bool update = false;
        for(int i = 0; i < E; i++)
        {
            if(d[e[i].u] != INF && d[e[i].v] > d[e[i].u] + e[i].cost)
            {
                d[e[i].v] = d[e[i].u] + e[i].cost;
                update = true;
            }
        }
    }
}
//判负圈
bool find_negative_loop()
{
    memset(d, 0, sizeof(d));
    for(int i = 0; i < V; i++)
    {
        for(int j = 0; j < E; j++)
        {
            if(d[e[j].v] > d[e[i].u] + e[j].cost)
            {
                d[e[j].v] = d[e[j].u] + e[j].cost;
                if(i == V - 1)
                    return true;
                //循环了V次后还不能收敛，即存在负圈
            }
        }
    }
    return false;
}

//spfa算法 $O(|E|\log{|V|})$
//适用于负权图和稀疏图, 稳定性不如dijstra
//存在负环返回false
int dist[MAXV];
int outque[MAXV];//出队次数, 如果大于V, 证明有负圈
bool vis[MAXV];
bool spfa(int s)
{
    for(int i = 0; i < V; i++)
    {
        vis[i] = false;
        dist[i] = INF;
        outque[i] = 0;
    }
    dist[s] = 0;
    queue<int> que;
    que.push(s);
    vis[s] = true;
    while(!que.empty())
    {
        int u = que.front();
        que.pop();
        vis[u] = false;
        if(++outque[u] > V) return false;
        for(int i = head[u]; i != -1; i = e[i].next)
        {
            int v = e[i].to;
            if(dist[v] <= dist[u] + e[i].cost) continue;
            dist[v] = dist[u] + e[i].cost;
            if(vis[v]) continue;
            vis[v] = true;
            que.push(v);
        }
    }
    return true;
}

///任意两点间最短路
//Floyd-Warshall算法 $O(|V|^3)$
int dist[MAXV][MAXV];
void floyd_warshall(int V)
{
    int i, j, k;
    for(k = 0; k < V; k++)
        for(i = 0; i < V; i++)
            for(j = 0; j < V; j++)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
}
```

###网络流
```
///最大流 maximum flow
//最大流最小割定理: 最大流 = 最小割
//常数比较: 高标推进 < SAP(gap) < dinic < sap < bfs + ek
///FF算法 Ford-Fulkerson算法 $O(F|E|)$ F为最大流量
//1. 初始化：原边容量不变，回退边容量为0，max_flow = 0
//2. 在残留网络中找到一条从源S到汇T的增广路，找不到得到最大流max_flow
//3. 增广路中找到瓶颈边，max_flow加上其容量
//4. 增广路中每条边减去瓶颈边容量，对应回退边加上其容量

struct edge {int next, to, cap;} e[MAXE];
int head[MAXV], tot;
void gInit() {memset(head, -1, sizeof(head)); tot = 0;}
void add_edge(int u, int v, int cap) {
	e[tot] = (edge) {head[u], v, cap}; head[u] = tot++;
	e[tot] = (edge) {head[v], u, 0}; head[v] = tot++;
}
int used[MAXV], time_stamp;
int dfs(int u, int t, int f) {
	if(u == t) return f;
	used[u] = time_stamp;
	for(int i = head[u]; ~i; i = e[i].next) {
		int v = e[i].to;
		if(used[v] != time_stamp && e[i].cap > 0) {
			int d = dfs(v, t, min(f, e[i].cap));
			if(d > 0) {
				e[i].cap -= d;
				e[i ^ 1].cap += d;
				return d;
			}
		}
	}
	return 0;
}

int max_flow(int s, int t) {
	int flow = 0, cur_flow;
	memset(used, 0, sizeof(used));
	time_stamp = 0;
	for(;;) {
		++time_stamp;
		if((cur_flow = dfs(s, t, INF)) == 0)
			return flow;
		flow += cur_flow;
	}
}
///Dinic算法 $O(|E| \cdot |V|^2)$
//似乎比链式前向星快
struct edge {int to, cap, rev;};
vector <edge> G[MAXV];
int level[MAXV];
int iter[MAXV];
void gInit() {
	for(int i = 0; i < MAXV; i++)
		G[i].clear();
}
void add_edge(int from, int to, int cap) {
	G[from].push_back((edge) {to, cap, (int) G[to].size()});
	G[to].push_back((edge) {from, 0, (int) G[from].size() - 1 });
}
bool bfs(int s, int t) {
	memset(level, -1, sizeof(level));
	queue <int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty()) {
		int v = que.front();
		que.pop();
		for(int i = 0; i < (int)G[v].size(); i++) {
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0) {
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
	return level[t] != -1;
}

int dfs(int v, int t, int f) {
	if(v == t) return f;
	for(int &i = iter[v]; i < (int)G[v].size(); i++) {
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to]) {
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0) {
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

int max_flow(int s, int t) {
	int flow = 0, cur_flow;
	while(bfs(s, t)) {
		memset(iter, 0, sizeof(iter));
		while((cur_flow = dfs(s, t, INF)) > 0) flow += cur_flow;
	}
	return flow;
}
///SAP(Shortest Augmenting Paths)算法 $O(|E| \cdot |V|^2)$
const int MAXV = 1000 + 10, MAXE = MAXV * MAXV;
struct edge {int next, to, cap;} e[MAXE];
int head[MAXV], tot, V;
void gInit() {memset(head, -1, sizeof(head)); tot = 0; V = 0;}
void add_edge(int u, int v, int cap) {
	e[tot] = (edge) {head[u], v, cap}; head[u] = tot++;
	e[tot] = (edge) {head[v], u, 0}; head[v] = tot++;
}

int h[MAXV];//距离标号数组
int numh[MAXV];//用于GAP优化的统计高度数量数组
int iter[MAXV];//当前弧优化
int Prev[MAXV];//前驱结点
int sap(int s, int t) {
	memset(h, 0, sizeof(h));
	memset(numh, 0, sizeof(numh));
	memset(Prev, -1, sizeof(Prev));
	for(int i = 0; i < V; ++i) iter[i] = head[i];//从0开始的图，初始化为第一条邻接边
	numh[0] = V;
	int u = s, max_flow = 0, i;
	while(h[s] < V) {
		if(u == t) { //增广成功
			int flow = INF, neck = -1;
			for(u = s; u != t; u = e[iter[u]].to) {
				if(flow > e[iter[u]].cap) {
					neck = u;
					flow = e[iter[u]].cap;
				}
			}//寻找"瓶颈"边
			for(u = s; u != t; u = e[iter[u]].to) {
				e[iter[u]].cap -= flow;
				e[iter[u] ^ 1].cap += flow;
			}//修改路径上的边容量
			max_flow += flow;
			u = neck;//下次增广从瓶颈边之前的结点开始
		}
		//寻找可行弧
		for(i = iter[u]; ~i; i = e[i].next)
			if(e[i].cap > 0 && h[u] == h[e[i].to] + 1)
				break;
		if(i != -1) {
			iter[u] = i;
			Prev[e[i].to] = u;
			u = e[i].to;
		}
		else {
			if(0 == --numh[h[u]]) break;//GAP优化
			iter[u] = head[u];
			for(h[u] = V, i = head[u]; ~i; i = e[i].next) {
				if(e[i].cap > 0) {
					h[u] = min(h[u], h[e[i].to]);
				}
			}
			++h[u];
			++numh[h[u]];
			if(u != s) u = Prev[u];//从标号并且从当前结点的前驱重新增广
		}
	}
	return max_flow;
}

///EK(Edmonds_Karp)算法 $O(|V| \cdot |E|^2)$
//bfs寻找增广路
const int MAXV = 210;
int n, m, g[MAXV][MAXV], prev[MAXV];
bool vis[MAXV];
bool bfs(int s, int t) {
	std::queue<int> que;
	memset(prev, -1, sizeof(prev));
	memset(vis, 0, sizeof(vis));
	que.push(s);
	vis[s] = true;
	while(!que.empty()) {
		int u = que.front(); que.pop();
		if(u == t) return true;
		for(int i = 1; i <= n; ++i)
			if(!vis[i] && g[u][i]) {
				vis[i] = true;
				prev[i] = u;
				que.push(i);
			}
	}
	return false;
}
int EK_max_flow(int s, int t) {
	int u, flow = 0, minv;
	while(bfs(s, t)) {
		for(minv = INF, u = t; prev[u] != -1; u = prev[u])
			minv = std::min(minv, g[prev[u]][u]);
		flow += minv;
		for(u = t; prev[u] != -1; u = prev[u]) {
			g[prev[u]][u] -= minv;
			g[u][prev[u]] += minv;
		}
	}
	return flow;
}
```

###最小割
定义:
割: 网络$(V,E)$的割$(cut)[S,T]$将点集$V$划分为$S$和$T(T=V-S)$两个部分, 使得源$s \in S$, 汇$t \in T$. 符号$[S,T]$代表一个边集合$\{ < u,v > | < u,v> \in E, u \in S, v \in T \}$. 穿过割$[S,T]$的净流$(net flow)$定义为$f(S,T)$, 容量$(capacity)$定义为$c(S,T)$.
最小割: 该网络中容量最小的割
(割与流的关系) 在一个流网络$G(V, E)$中, 设其任意一个流为$f$, 且$[S, T]$为$G$一个割. 则通过割的净流为$f(S, T) = |f|$.
(对偶问题的性质) 在一个流网络G(V, E)中, 设其任意一个流为f, 任意一个割为[S, T], 必有$|f| \leq c[S, T]$.
(最大流最小割定理) 如果f是具有源s和汇t的流网络G(V,E)中的一个流,则下列条件是等价的:
    (1) f是G的一个最大流
    (2) 残留网络$G_f$不包含增广路径
    (3) 对G的某个割[S,T], 有|f|=c[S,T]
    即最大流的流值等于最小割的容量
性质:
    性质1(不连通): 在给定的流网络中, 去掉割的边集, 则不存在任何一条从源到汇的路径.
    性质2(两类点): 在给定的流网络中, 任意一个割将点集划分成两部分. 割为两部分点之间的"桥梁".
技巧:
    技巧1 用正无限容量排除不参与决策的边.
    技巧2 使用割的定义式来分析最优性.
    技巧3 利用与源或汇关联的边容量处理点权.
最小割的求法:
  1. 先求的最大流
  2. 在得到最大流f后的残留网络$G_f$中,从源s开始深度优先遍历(DFS),所有被遍历的点, 即构成点集S
  注意: 虽然最小割中的边都是满流边, 但满流边不一定都是最小割的边.
  注意: 如果在无向图中从汇点遍历求点集T, 需要看反向边的容量是否为0, 即e[i^1].cap > 0
最小割唯一性判断(zoj2587): 遍历得到的点集|S| + |T| == V
```
int max_flow(int s, int t) {}
int getST(int s, int t, int vis[]) {
  int mincap = max_flow(s, t);
  memset(vis, 0, sizeof(vis));
  queue<int> que;
  que.push(s);
  vis[s] = 1;
  while (!que.empty()) {
    int u = que.front(); que.pop();
    for (int i = 0; i < (int)g[u].size(); i++) //travel v
      if (g[u][i].cap > 0 && !vis[g[u][i].to]) {
        vis[g[u][i].to] = 1;
        que.push(g[u][i].to);
      }
  }
  return mincap;
}
```
###无向图全局最小割 Stoer-Wagner算法
定理: 对于图中任意两点s和t来说, 无向图G的最小割要么为s到t的最小割, 要么是生成图G/{s,t}的最小割(把s和t合并)
算法的主要部分就是求出当前图中某两点的最小割, 并将这两点合并
快速求当前图某两点的最小割:
1. 维护一个集合A, 初始里面只有$v_1$(可以任意)这个点
2. 区一个最大的w(A, y)的点y放入集合A(集合到点的权值为集合内所有点到该点的权值和)
3. 反复2,直至A集合G集相等
4. 设最后两个添加的点为s和t, 那么w(G-{t}, t)的值, 就是s到t的cut值

```
//$O(|V|^3)$
const int MAXV = 510;
int n;
int g[MAXV][MAXV];//g[u][v]表示u,v两点间的最大流量
int dist[MAXV];//集合A到其他点的距离
int vis[MAXV];
int min_cut_phase(int &s, int &t, int mark) { //求某两点间的最小割
  vis[t] = mark;
  while (true) {
    int u = -1;
    for (int i = 1; i <= n; i++)
      if (vis[i] < mark && (u == -1 || dist[i] > dist[u])) u = i;
    if (u == -1) return dist[t];
    s = t, t = u;
    vis[t] = mark;
    for (int i = 1; i <= n; i++) if (vis[i] < mark) dist[i] += g[t][i];
  }
}

int min_cut() {
  int i, j, res = INF, x, y = 1;
  for (i = 1; i <= n; i++)
    dist[i] = g[1][i], vis[i] = 0;
  for (i = 1; i < n; i++) {
    res = min(res, min_cut_phase(x, y, i));
    if (res == 0) return res;
    //merge x, y
    for (j = 1; j <= n; j++) if (vis[j] < n) dist[j] = g[j][y] = g[y][j] = g[y][j] + g[x][j];
    vis[x] = n;
  }
  return res;
}

// 优先队列优化 $O(|V|(|E| + |V|)\log{|V|})$
const int MAXV = 3010, MAXE = 2e5 + 10;
int n;
struct edge {int next, to, cost;} e[MAXE];
int head[MAXV], tot;
void gInit() {memset(head, -1, sizeof(head)); tot = 0;}
void add_edge(int u, int v, int w) {
  e[tot] = {head[u], v, w};
  head[u] = tot++;
}
int dist[MAXV];//集合A到其他点的距离
int vis[MAXV];
int min_cut_phase(int &s, int &t, int vist) { //求某两点间的最小割
  int x = 0;
  for (int i = 1; i <= n; ++i) {
    if (vis[i] < vist) {
      dist[i] = 0;
      ++x;
    }
  }
  priority_queue<PII> que;
  que.push(PII(0, s));
  while (x) {
    PII p = que.top();
    que.pop();
    if (vis[p.SE] == vist) continue;
    --x;
    s = t;
    t = p.SE;
    vis[t] = vist;
    for (int i = head[t]; ~i; i = e[i].next) {
      if (vis[e[i].to] != vist) {
        dist[e[i].to] += e[i].cost;
        que.push(PII(dist[e[i].to], e[i].to));
      }
    }
  }
  return dist[t];
}

int min_cut() {
  int res = INF, s = 1, t;
  for (int i = 1; i <= n; i++) vis[i] = 0;
  for (int i = 1; i < n; i++) {
    res = min(res, min_cut_phase(s, t, i));
    if (res == 0) return res;
    //merge x, y
    vis[t] = n;
    int j = head[t], k;
    while (~j) {
      k = e[j].next;
      e[j].next = head[s];
      head[s] = j;
      e[j ^ 1].to = s;
      j = k;
    }
  }
  return res;
}
```

###最大权闭合图 Maximum Weight Closure of a Graph
定义:
定义一个有向图G(V, E)的闭合图(closure)是该有向图的一个点集, 且该点集的所有出边都还指向该点集. 即闭合图内的任意点的任意后继也一定在闭合图中. 更形式化地说, 闭合图是这样的一个点集$V' \in V$，满足对于$\forall u \in V'$引出的$\forall <u,v> \in E$, 必有$v \in V'$成立. 还有一种等价定义为: 满足对于$\forall <u, v> \in E$ , 若有$u \in V'$成立，必有$v \in V'$成立, 在布尔代数上这是一个"蕴含(imply)"的运算. 按照上面的定义，闭合图是允许超过一个连通块的.给每个点v分配一个点权$w_v$(任意实数, 可正可负). 最大权闭合图(maximum weight closure), 是一个点权之和最大的闭合图，即最大化$\displaystyle \sum_{v\in V'}{w_v}$.
转化为最小割模型$G_N(V_N, E_N)$
在原图点集的基础上增加源s和汇t; 将原图每条有向边$<u, v> \in E>$替换为容量为$c(u, v) = \infty$的有向边$<u, v> \in E_N$; 增加连接源s到原图每个正权点$v(w_v > 0)$的有向边$<s, v> \in E_N$, 容量为$c(s, v) = w_v$, 增加连接原图每个负权点$v(w_v < 0)$到汇t的有向边$<v, t> \in E_N$, 容量为$c(v, t) = -w_v$. 其中, 正无限$\infty$定义为任意一个大于$\sum_{v\in V}{|w_v|}$的整数。更形式化地, 有:
$$ V_N = V \cup \{s, t\} $$
$$	E_N = E \cup \{< s, v > | v \in V, w_v > 0\} \cup \{< v, t > | v \in V, w_v < 0\}$$
$$	\left\{ \begin{array}{l l}
			c(u, v) = \infty &< s, v> \in E \\
			c(s, v) = w_v & w_v > 0 \\
			c(v, t) = -w_v & w_v < 0
		\end{array} \right.$$
当网络N的取到最小割时, 其对应的图G的闭合图将达到最大权.

	
###最大密度子图 a Maximum Density Subgraph
定义:
	定义无向图$G=(V, E)$的密度(density)D 为该图的边数$|E|$与该图的点数$|V|$的比值$\displaystyle D = \frac{|E|}{|V|}$.
	给一个无向图$G=(V, E)$, 其中具有最大密度的子图$G'=(V', E')$, 称为最大密度子图(maximum density subgraph), 即最大化$\displaystyle D' = \frac{|E'|}{|V'|}$.
做法:
	先转化为分数规划, 在转化为最小割即可.

###有上下界的网络流
设原来的源点为src, 汇点为sink. 新建一个超级源S和超级汇T, 对于原网络中的每一条边<u, v>, 上界U, 下界L, 拆分为三条边
	1). <u, T> 容量L  2). <S, v> 容量L 3). <u, v> 容量U - L
	最后添加边<sink, src>, 容量$+\infty$.
	在新建的网络上, 计算从S到T的最大流, 如果从S出发的每条边都是满流, 说明存在可行流, 否则不存在可行流.
	求出可行流后, 要继续求最大流, 将该可行流还原到原网络中, 从src到sink不断增广, 直至找不到增广路.
	要求最小流: 先不连<sink, src>, 计算S到T的最大流, 然后连<sink, src>容量$+\infty$, 并不断从S寻找到T的增广路, 这进一步增广的流量就是最小流
	实现的时候, 要将从S连向同一结点, 同一结点连向T的多条边合并成一条(容量增加).

###费用流
```
//不断寻找最短路增广即可
//复杂度: $O(F \cdot MaxFlow(G))$
//对于稀疏图的效率较高, 对于稠密图的的效率低
///dijkstra实现 基于0开始的图
const int MAXV = 11000, MAXE = 41000;
struct edge {int next, to, cap, cost;} e[MAXE << 1];
int head[MAXV], htot;
void init() {
  memset(head, -1, sizeof(head));
  htot = 0;
}
void add_edge(int u, int v, int cap, int cost) {
  e[htot] = (edge) {head[u], v, cap, cost};
  head[u] = htot++;
  e[htot] = (edge) {head[v], u, 0, -cost};
  head[v] = htot++;
}
int dist[MAXV];
int Prev[MAXV], pree[MAXV];
int h[MAXV], V;
void dijkstra(int s) {
  priority_queue<P, vector<P>, greater<P> > que;
  fill(dist, dist + V, INF);
  que.push(P(0, s));
  dist[s] = 0;
  while (!que.empty()) {
    P p = que.top(); que.pop();
    int u = p.SE;
    if (dist[u] < p.FI) continue;
    for (int i = head[u]; ~i; i = e[i].next)
      if (e[i].cap > 0 && dist[e[i].to] > dist[u] + e[i].cost + h[u] - h[e[i].to]) {
        dist[e[i].to] = dist[u] + e[i].cost + h[u] - h[e[i].to];
        Prev[e[i].to] = u;
        pree[e[i].to] = i;
        que.push(P(dist[e[i].to], e[i].to));
      }
  }
}
int min_cost_flow(int s, int t, int flow) {
  int min_cost = 0;
  memset(h, 0, sizeof(h));
  //如果初始有费用为负，第一次求最短用bellman-ford算法
  /*
  for(bool f = true; f;) {
    f = false;
    for(int u = 0; u < V; ++u)
      for(int i = head[u]; ~i; i = e[i].next)
        if(e[i].cap > 0 && h[e[i].to] > h[u] + e[i].cost)
          h[e[i].to] = h[u] + e[i].cost, f = true;
  }
  */
  while (flow > 0) {
    dijkstra(s);
    if (dist[t] == INF)
      return -1;
    for (int i = 0; i < V; i++)
      h[i] += dist[i];
    int now_flow = flow;
    for (int u = t; u != s; u = Prev[u]) //寻找瓶颈边
      now_flow = min(now_flow, e[pree[u]].cap);
    flow -= now_flow;
    min_cost += now_flow * (dist[t] - h[s] + h[t]);
    for (int u = t; u != s; u = Prev[u]) {
      e[pree[u]].cap -= now_flow;
      e[pree[u] ^ 1].cap += now_flow;
    }
  }
  return min_cost;
}

///spfa实现 基于0开始的图
int dist[MAXV];
int InQue[MAXV], Pree[MAXV], Prev[MAXV];
bool spfa(int s, int t) {
  memset(dist, 0x3f, sizeof(dist));
  //memset(InQue, 0, sizeof(InQue));
  queue<int> que;
  que.push(s);
  dist[s] = 0;
  InQue[s] = 1;
  while (!que.empty()) {
    int u = que.front(); que.pop();
    InQue[u] = 0;
    for (int i = head[u]; ~i; i = e[i].next) {
      int v = e[i].to;
      if (e[i].cap > 0 && dist[v] > dist[u] + e[i].cost) {
        dist[v] = dist[u] + e[i].cost;
        Pree[v] = i;
        Prev[v] = u;
        if (InQue[v] == 0) {
          InQue[v] = 1;
          que.push(v);
        }
      }
    }
  }
  return dist[t] != 0x3f3f3f3f;
}
int min_cost_flow(int s, int t, int flow) {
  int ans = 0;
  while (flow > 0 && spfa(s, t)) {
    int cur_flow = flow;
    for (int u = t; u != s; u = Prev[u])
      cur_flow = min(cur_flow, e[Pree[u]].cap);
    flow -= cur_flow;
    ans += dist[t] * cur_flow;
    for (int u = t; u != s; u = Prev[u]) {
      e[Pree[u]].cap -= cur_flow;
      e[Pree[u] ^ 1].cap += cur_flow;
    }
  }
  return ans;
}

///zkw最小费用流, 在稠密图上很快
const int MAXV = 11000, MAXE = 41000;
struct edge {int next, to, cap, cost;} e[MAXE << 1];
int head[MAXV], htot;
int V;
void gInit() {
  memset(head, -1, sizeof(head));
  htot = 0;
}
void add_edge(int u, int v, int cap, int cost) {
  e[htot] = (edge) {head[u], v, cap, cost};
  head[u] = htot++;
  e[htot] = (edge) {head[v], u, 0, -cost};
  head[v] = htot++;
}
int dist[MAXV];
int slk[MAXV];
int src, sink;//源和汇
bool vis[MAXV];
int min_cost;//最小费用
int aug(int u, int f) {
  int left = f;
  if (u == sink) {
    min_cost += f * dist[src];
    return f;
  }
  vis[u] = true;
  for (int i = head[u]; ~i; i = e[i].next) {
    int v = e[i].to;
    if (e[i].cap > 0 && !vis[v]) {
      int t = dist[v] + e[i].cost - dist[u];
      if (t == 0) {
        int delta = aug(v, min(e[i].cap, left));
        if (delta > 0) e[i].cap -= delta, e[i ^ 1].cap += delta, left -= delta;
        if (left == 0) return f;
      }
      else
        slk[v] = min(t, slk[v]);
    }
  }
  return f - left;
}

bool modlabel() {
  int delta = INF;
  for (int i = 0; i < V; i++)
    if (!vis[i]) delta = min(delta, slk[i]), slk[i] = INF;
  if (delta == INF) return false;
  for (int i = 0; i < V; i++)
    if (vis[i]) dist[i] += delta;
  return true;
}

int zkw_min_cost_flow(int s, int t) {
  src = s, sink = t;
  min_cost = 0;
  int flow = 0;
  memset(dist, 0, sizeof(dist));
  memset(slk, 0x3f, sizeof(slk));
  int tmp = 0;
  do {
    do {
      memset(vis, false, sizeof(vis));
      flow += tmp;
    }
    while ((tmp = aug(src, INF)));
  }
  while (modlabel());
  return min_cost;
}
```


###二分图匹配

### 最小点覆盖
二分图最小点覆盖等于二分图最大匹配
点覆盖方案构造:设二分图左集合为$L$,右集合为$R$,跑完二分图匹配后,再对所有点跑一次增广,$L$中的所有未被访问过的点和$R$中的所有访问过的点即构成了一组解
####二分图的最小点权覆盖集与最大点权独立集
定义:
点覆盖集 (vertex covering set, VCS) 是无向图的G的一个点集, 使得该图中所有边都至少有一个端点在该集合内. 形式化的定义: 点覆盖集为 $V' \in V$, 满足对于$\forall (u, v) \in E$, 都有 $u \in V'$ 或 $v \in V'$.
点独立集 (vertex independent set, VIS) 是无向图的G的一个点集, 使得任意两个在该集合中的点在原图中都不相邻, 即导出子图为零图(没有边)的点集. 形式化的定义: 点独立集是$V' \in V$, 满足$\forall u, v \in V'$, 都有$(u, v) \not \in E$成立. 等价的定义: 点独立集为$V' \in V$, 满足$\forall (u, v) \in E$, 都有$u \in V'$与$v \in V'$不同时成立.
最小点覆盖集 (minimum vertex covering set, MinVCS) 是在无向图G中, 点数最少的点覆盖集.
最大点独立集 (maximum vertex independent set, MaxVIS) 是在无向图G中, 点数最多的点独立集.
一个带点权无向图$G = (V, E)$, 对于$\forall v \in V$, 都被分配一个非负点权$w_v$.
最小点权覆盖集 (minimum weight vertex covering set, MinWVCS) 是在带点权无向图G中, 点权之和最小的点覆盖集.
最大点权独立集 (maximum weight vertex independent set, MaxWVIS) 是在带点权无向图G中, 点权之和最大的点独立集.
带权二分图$G = (V, E)$中, 其中$V = X \cup Y, X \cap Y = \varnothing$, 且对于$\forall v \in V$, 都被分配了一个非负的权值$w_v (w_v \geq 0)$.
####二分图的最小点权覆盖集算法 Algorithm for MinWVCS in a Bipartite Graph
考虑二分图的网络流解法, 它加入了额外的源s和汇t, 将匹配以一条条$s-u-v-t$形式的流路径"串联"起来.
同样, 如上建图, 建立一个源s, 向X部每个点连边; 建立一个汇t, 从Y部每个点向汇t连边. 把二分图看做有向的, 则任意一条从s到t的路径, 一定具有$s-u-v-t$的形式. 割的性质是不存在一条从s到t的路径, 故路径上的三条边$(s, u), (u, v), (v, t)$中至少有一条在割中. 若人为的令边$(u, v)$不在最小割中, 则令其容量为正无限$c(u, v) = +\infty$, 则条件简化为 $(s, u), (v, t)$至少有一条边在最小割中, 正好和点覆盖集的形式相对应($u \in V'$或$v \in V'$).
将二分图G的最小点权覆盖向网络$N=(V_N, E_N)$的最小割模型的转化:
	在图G的基础上添加源s和汇t; 将每条二分图的边替换为容量为$c(u, v) = \infty$的有向边$(u, v) \in E_N$; 增加源s到X部的点u的有向边$(s, u) \in E_N$, 容量即为改点的权值$c(s, u) = w_u$; 增加Y部的点v到汇t有向边的$(v, t) \in E_N$, 同样容量为该点的权$c(v, t) = w_v$.
引理: 网络N的简单割[S, T]与图G的点覆盖集$V' = X' \cup Y'$存在一一对应关系: 点覆盖集中的点在网络N中相应的带权边组成一个简单割; 反之亦然, 即: 
$$[S, T] = [{s}, X'] \cup [Y', {t}]$$
由于最小点覆盖和最小割的优化方向一致, 故带权二分图的最小点覆盖转化为最小割模型. 
复杂度: $O(MaxFlow(N))$

####二分图的最大点权独立集算法
点独立集定义重写, 可以得到其补图的点覆盖集定义. 即
$$
	\overline{u \in V' \quad and \quad v \in V'} = u \in \overline{V'}\  or\  v \in \overline{V'}$$
定理 (覆盖集与独立集互补定理): 若$\overline{V'}$为不含孤立点的任意图的一个点覆盖集当且仅当V'是该图的一个点独立集.
推论 (最优性)若V'为不含孤立点的任意图的一个最小点权覆盖集, 则$\overline{V'}$就是该图的一个最大点权独立集.
求出最大点权独立点集后还有加上反图中的孤立点才是答案.
复杂度: $O(MaxFlow(N))$


####霍尔定理
二分图一侧的子图$V$有完全匹配，当且仅当对$V$的任意子集$A$,和$A$直接相连的点的个数大于等于$A$的点的个数
如果一个点集$S$满足上述条件,那么它一定是一个完美匹配的子集
霍尔定理也可以求匹配数:$|V| - max(|A| - T(A))$,$T(A)$是指另一侧中和$A$直接相连的点的个数

```
const int maxn = 1005;
vector<int>g[maxn];
int mx[maxn], my[maxn];
queue<int>q;
int dx[maxn], dy[maxn];
bool vis[maxn], vx[maxn];

bool ff(int u) {
    vx[u] = 1;
    for(auto v : g[u]) {
        if(!vis[v] && dy[v] == dx[u] + 1) {
            vis[v] = 1;
            if(!my[v] || ff(my[v])) {
                mx[u] = v;
                my[v] = u;
                return true;
            }
        }
    }
    return false;
}

int match(int n) {
    memset(mx, 0, sizeof(mx));
    memset(my, 0, sizeof(my));
    int ans = 0;
    while(1) {
        bool flag = 0;
        while(!q.empty()) q.pop();
        memset(dx, 0, sizeof(dx));
        memset(dy, 0, sizeof(dy));
        for(int i = 1; i <= n; i++) {
            if(!mx[i]) q.push(i);
        }
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            for(auto v : g[u]) {
                if(!dy[v]) {
                    dy[v] = dx[u] + 1;
                    if(my[v]) {
                        dx[my[v]] = dy[v] + 1;
                        q.push(my[v]);
                    } else flag = 1;
                }
            }
        }
        if(!flag) break;
        memset(vis, 0, sizeof(vis));
        for(int i = 1; i <= n; i++) {
            if(!mx[i] && ff(i)) ans++;
        }
    }
	//构造点覆盖的解
	// !vx[i] 和 vis[i] 为解的点集
	/*
    memset(vis, 0, sizeof(vis));
    memset(vx, 0, sizeof(vx));
    for(int i = 1; i <= n; i++) {
        if(!mx[i]) ff(i);
    }
	for(i = 1;i <= r; i++) {   //左边的点集
        if(!vx[i]) printf(" r%d",i);
    }
    for(i = 1;i <= c; i++) {   //右边的点集
        if(vis[i]) printf(" c%d",i);
    }
	*/
    return ans;
}
```

###最大权匹配
```
const int maxn = 205;
const LL INF = 1LL * mod * mod;
LL w[maxn][maxn];
LL lx[maxn], ly[maxn];
int linky[maxn], visy[maxn], pre[maxn];
LL slack[maxn];
int nx, ny;
void bfs(int k) {
    int px, py = 0, yy = 0;
    LL d;
    memset(pre, 0, sizeof(pre));
    for(int i = 1; i <= ny; i++) slack[i] = INF;
    linky[py] = k;
    do {
        px = linky[py], d = INF, visy[py] = 1;
        for(int i = 1; i <= ny; i++) {
            if(!visy[i]) {
                if(slack[i] > lx[px] + ly[i] - w[px][i])
                    slack[i] = lx[px] + ly[i] - w[px][i], pre[i] = py;
                if(slack[i] < d) d = slack[i], yy = i;
            }
        }
        for(int i = 0; i <= ny; i++) {
            if(visy[i]) lx[linky[i]] -= d, ly[i] += d;
            else slack[i] -= d;
        }
        py = yy;
    } while(linky[py] != 0);
    while(py) linky[py] = linky[pre[py]], py = pre[py];
}
LL KM() {
    memset(lx, 0, sizeof(lx));
    memset(ly, 0, sizeof(ly));
    memset(linky, 0, sizeof(linky));
    for(int i = 1; i <= nx; i++) {
        memset(visy, 0, sizeof(visy));
        bfs(i);
    }
    LL res = 0;
    for(int i = 1; i <= nx; i++) res += lx[i];
    for(int i = 1; i <= ny; i++) res += ly[i];
    return res;
}
```

###最小树形图
```
需清零pre数组和ecnt
#define N 550
#define M 1109

int ecnt;
struct Edge{
        int u , v;
        int cost;
}E[N * 2 + M];
void addedge(int u,int to, int cost) {
        E[ecnt++] = (Edge){u, to, cost};
}

const int inf=(1)<<30;
int pre[N],ID[N],vis[N];
int In[N];
// 输入树根  点个数 边个数
int Directed_MST(int root,int NV,int NE) {
        int ret = 0;
        while(true) {
                for(int i=0;i<NV;i++) In[i] = inf;
                for(int i=0;i<NE;i++){
                        int u = E[i].u;
                        int v = E[i].v;
                        if(E[i].cost < In[v] && u != v) {
                                pre[v] = u;
                                In[v] = E[i].cost;
                        }
                }
                for(int i=0;i<NV;i++) {
                        if(i == root) continue;
                        if(In[i] == inf)    return -1;//除了跟以外有点没有入边,则根无法到达它
                }
                //2.找环
                int cntnode = 0;
                memset(ID,-1,sizeof(ID));
                memset(vis,-1,sizeof(vis));
                In[root] = 0;
                for(int i=0;i<NV;i++) {//标记每个环
                        ret += In[i];
                        int v = i;
                        while(vis[v] != i && ID[v] == -1 && v != root) {
                                vis[v] = i;
                                v = pre[v];
                        }
                        if(v != root && ID[v] == -1) {
                                for(int u = pre[v] ; u != v ; u = pre[u]) {
                                        ID[u] = cntnode;
                                }
                                ID[v] = cntnode ++;
                        }
                }
                if(cntnode == 0)    break;//无环
                for(int i=0;i<NV;i++) if(ID[i] == -1) {
                        ID[i] = cntnode ++;
                }
                //3.缩点,重新标记
                for(int i=0;i<NE;i++) {
                        int v = E[i].v;
                        E[i].u = ID[E[i].u];
                        E[i].v = ID[E[i].v];
                        if(E[i].u != E[i].v) {
                                E[i].cost -= In[v];
                        }
                }
                NV = cntnode;
                root = ID[root];
        }
        return ret;
}
```


### 平面图转对偶图
```
typedef long long LL;
typedef pair<int,int> P;
typedef pair<int,P> PI;
typedef pair<double,int> PD;

const int maxn = 2e5 + 5;
const double eps = 1e-8;
const double pi = acos(-1);
inline int sgn(double x) {
    if(x < -eps) return -1;
    else if(x > eps) return 1;
    else return 0;
}
struct Point {
    int x,y;
    Point(int _x = 0,int _y = 0): x(_x),y(_y) {}
    Point operator + (const Point &b) const {
        return Point(x + b.x,y + b.y);
    }
    Point operator - (const Point &b) const {
        return Point(x - b.x,y - b.y);
    }
    LL operator * (const Point &b) const {
        return (1LL * x * b.x + 1LL * y * b.y);
    }
    LL operator ^ (const Point &b) const {
        return (1LL * x * b.y - 1LL * y * b.x);
    }
};
Point p[maxn];
P f[maxn];
int n,m,num,id[maxn * 2];
bool vis[maxn * 2];
map<P,int> mp;
vector<PD> g[maxn];
unordered_map<int,int> gg[maxn];
int sk;

double get_ang(int u,int v) {
    return atan2(p[v].y - p[u].y,p[v].x - p[u].x);
}

//f数组表示该简单多边形的边
//id表示这条边所属的两个块
void work(int u,PD e) {
    int v1 = u,v2 = e.second,k = 0;
    f[k++] = P(v1,v2);
    while(v2 != u) {
        v1 = gg[v2][v1];
        if(v1 == 0) v1 = g[v2].back().second;
        else v1 = g[v2][v1 - 1].second;
        swap(v1,v2);
        f[k++] = P(v1,v2);
    }
    ++num;
    for(int i = 0; i < k; i++) {
        assert(mp.find(f[i]) != mp.end());
        int j = mp[f[i]];
        assert(!vis[j]);
        vis[j] = 1;
        id[j] = num;
    }
//    LL ss = 0;
//    for(int i = 0; i < k; i++) ss += p[f[i].first] ^ p[f[i].second];
// ss小于0表示是外边界
}


bool cmp(const PD &a,const PD &b) {
    if(sgn(b.first - a.first) == 0) return ((p[b.second] - p[sk]) ^ (p[a.second] - p[sk])) < 0;
    else return b.first - a.first > eps;
}

void build() {
    int i,j;
    for(i = 1; i <= n; i++) {
        sk = i;
        sort(g[i].begin(),g[i].end(),cmp);
        for(j = 0; j < (int)g[i].size(); j++) gg[i][g[i][j].second] = j;
    }
    for(i = 1; i <= n; i++) {
        for(auto e:g[i]) {
            j = mp[P(i,e.second)];
            if(vis[j]) continue;
            work(i,e);
        }
    }
}

void init() {
    num = 0;
    mp.clear();
    memset(vis,0,sizeof(vis));
    for(int i = 1; i <= n; i++) g[i].clear();
    for(int i = 1; i <= n; i++) gg[i].clear();
}

int w[maxn],pf[maxn],fu[maxn];

int ff(int u) {
    if(pf[u] != u) pf[u] = ff(pf[u]);
    return pf[u];
}

bool cmp2(const int &a,const int &b) {
    return w[a] < w[b];
}

void solve() {
    int i,j,u,v;
    init();
    for(i = 1; i <= n; i++) scanf("%d%d",&p[i].x,&p[i].y);
    for(i = 0; i < m; i++) {
        scanf("%d%d%d",&u,&v,&w[i]);
        g[u].push_back(PD(get_ang(u,v),v));
        g[v].push_back(PD(get_ang(v,u),u));
        mp[P(u,v)] = i << 1;
        mp[P(v,u)] = i << 1 | 1;
    }
    build();
}
```

### 一般图匹配
转二分图做法: 对于每个联通块,将每个点$u$拆成二分图的左右两个点$u_{l},u_{r}$,对于一条边$<u,v>$,在二分图上连边$<u_{l},v_{r}>,<v_{l},u_{r}>$,然后跑二分图匹配,若原联通块的最大匹配为$k$,则该二分图的最大匹配为$2k$或$2k+1$
所以对每个联通块分别转二分图求最大匹配,然后求和即是答案(此方法无法求方案)

带花树算法:
```
/**
*一般图的最大基数匹配：带花树算法 复杂度n^3
*输入：g[][],n(输入从0到n-1,用addEdge()加边)
*输出：gao()(最大匹配数),match[](匹配)
*/
//const int maxn=0;
struct Matching{
    deque<int> Q;
    int n;
    //g[i][j]存放关系图：i,j是否有边,match[i]存放i所匹配的点
    bool g[maxn][maxn],inque[maxn],inblossom[maxn],inpath[maxn];
    int match[maxn],pre[maxn],base[maxn];

    //找公共祖先
    int findancestor(int u,int v){
        memset(inpath,0,sizeof(inpath));
        while(1){
            u=base[u];
            inpath[u]=true;
            if(match[u]==-1)break;
            u=pre[match[u]];
        }
        while(1){
            v=base[v];
            if(inpath[v])return v;
            v=pre[match[v]];
        }
    }

    //压缩花
    void reset(int u,int anc){
        while(u!=anc){
            int v=match[u];
            inblossom[base[u]]=1;
            inblossom[base[v]]=1;
            v=pre[v];
            if(base[v]!=anc)pre[v]=match[u];
            u=v;
        }
    }

    void contract(int u,int v,int n){
        int anc=findancestor(u,v);
        //SET(inblossom,0);
        memset(inblossom,0,sizeof(inblossom));
        reset(u,anc);
        reset(v,anc);
        if(base[u]!=anc)pre[u]=v;
        if(base[v]!=anc)pre[v]=u;
        for(int i=1; i<=n; i++)
            if(inblossom[base[i]]){
                base[i]=anc;
                if(!inque[i]){
                    Q.push_back(i);
                    inque[i]=1;
                }
            }
    }

    bool dfs(int S,int n){
        for(int i=0; i<=n; i++)pre[i]=-1,inque[i]=0,base[i]=i;
        Q.clear();
        Q.push_back(S);
        inque[S]=1;
        while(!Q.empty()){
            int u=Q.front();
            Q.pop_front();
            for(int v=1; v<=n; v++){
                if(g[u][v]&&base[v]!=base[u]&&match[u]!=v){
                    if(v==S||(match[v]!=-1&&pre[match[v]]!=-1))contract(u,v,n);
                    else if(pre[v]==-1){
                        pre[v]=u;
                        if(match[v]!=-1)Q.push_back(match[v]),inque[match[v]]=1;
                        else{
                            u=v;
                            while(u!=-1){
                                v=pre[u];
                                int w=match[v];
                                match[u]=v;
                                match[v]=u;
                                u=w;
                            }
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    void init(int n){
        this->n = n;
        memset(match,-1,sizeof(match));
        memset(g,0,sizeof(g));
    }

    void addEdge(int a, int b){
        ++a;
        ++b;
        g[a][b] = g[b][a] = 1;
    }

    int gao(){
        int ans = 0;
        for (int i = 1; i <= n; ++i)
            if (match[i] == -1 && dfs(i, n))
                ++ans;
        return ans;
    }
    
} match;

```

###支配树
```
vector <int> a[N], b[N], pre[N];
int dfn[N], cnt, idom[N], semi[N], f[N], best[N], n, m, id[N], fa[N];
long long ans[N];
// idom[x] 最近支配点 即到起点的路径上距离x最近的必经点
// semi[x] 最小半必经点 在dfs搜索树上x的祖先中能通过非树枝边到达x的深度最小的祖先
void input(int &r) { //手动读入
    char t;
    t = getchar();
    while (!isdigit(t)) t = getchar();
    r = 0;
    while (isdigit(t)) r = r * 10 + t - '0', t = getchar();
}

void init() { //初始化
    for (int i = 1; i <= n; i++)
        f[i] = best[i] = i;
    for (int i = 1; i <= n; i++)
        a[i].clear(), b[i].clear(), pre[i].clear(), id[i] = 0;
    for (int i = 1; i <= n; i++)
        dfn[i] = semi[i] = idom[i] = 0, fa[i] = 0, ans[i] = 0;
    cnt = 0;
}

void Dfs(int x) {
    dfn[x] = ++cnt;
    id[cnt] = x;//id[x]记录的是时间戳为x的节点是谁。
    int len = a[x].size();
    for (int i = 0; i <= len - 1; i++) {
        int y = a[x][i];
        if (!dfn[y])
            Dfs(y), fa[y] = x;
    }
}

bool cmp(int x, int y) {
    return dfn[semi[x]] < dfn[semi[y]];
}

int ff(int x) {
    if (f[x] == x)
        return x;
    int olfa = f[x];
    f[x] = ff(f[x]);
    best[x] = min(best[x], best[olfa], cmp);
    return f[x];
}

void Lengauer_Tarjan() {
    Dfs(n);//dfs获取时间戳,这里的起点为n
    dfn[0] = 0x3f3f3f3f;//这是一个很大的数,一开始的semi都是0,就让他的时间戳无穷大，就不会更新了
    for (int i = cnt; i >= 1; i--) { //时间戳从大到小处理
        int x = id[i];
        if (i != 1) {
            int len = b[x].size();//b是逆向边
            for (int j = 0; j <= len - 1; j++) {
                int y = b[x][j];
                if (!dfn[y]) continue;
                if (dfn[y] > dfn[x]) { //如果是dfs序大于的x节点的情况
                    //这个并查集里面包括的是时间戳大于某个节点且能够到达这个节点的点
                    ff(y);//找到所有大于这个节点x的dfs序的节点(一定要是能够到达x节点)
                    if (dfn[semi[best[y]]] < dfn[semi[x]])//如果时间戳最小的点的半必经点更优
                        semi[x] = semi[best[y]];//替换这个点的半必经点
                } else if (dfn[y] < dfn[semi[x]]) //这是它的直系父亲(dfn[p]<dfn[x])
                    semi[x] = y;//如果它的时间戳比之前更新的都小。那么它变成半必经点
            }
            pre[semi[x]].push_back(x);//记录那个半必经点是相对于谁的半必经点
        }
        while (pre[x].size()) { //这个相当于处理出x和semi[x]之间的那个y了。
            int y = pre[x].back();
            pre[x].pop_back();
            ff(y);
            //值得注意的是。因为我们是时间戳从大到小的顺序处理的。
            //所以semi[x]->x路径上的所有点必然已经加入到并查集中。
            //且semi[x]上面的点肯定没有包括在并查集中
            //因为semi[x]上面的点的时间戳肯定是小于semi[x]的；
            //而那些点我们等一下才要处理。
            if (semi[best[y]] != x)//如果在semi[y]->y之间存在一个点z
                //它的半必经点不等于y的半必经点 则说明要让idom[y] = idom[z];
                //但是idom[z]可能还没有处理出来。
                //所以我们就仅仅记录这个点z是什么.之后再处理
                idom[y] = best[y];
            else//如果等于的话,idom[y] = semi[y];
                idom[y] = x;
        }
        int len = a[x].size();
        for (int j = 0; j <= len - 1; j++) { //然后把这个点加入到并查集维护的森林中
            //当然。只有那些和他有关系的点(能够从这个点到达的点才要加入);
            int y = a[x][j];
            if (fa[y] == x)
                f[y] = x;
        }
    }
    for (int i = 2; i <= cnt; i++) {
        int x = id[i];
        if (idom[x] != semi[x])//这个利用上面处理出来的semi[x]->x路径上的点
            //利用必经点定理修改必经点
            idom[x] = idom[idom[x]];
    }
    idom[id[1]] = 0;
}

long long get_ans(int x) { //这个就是累加答案。
    if (x == n) {
        ans[x] = n;
        return ans[x];
    }
    if (ans[x])//用了记搜~~
        return ans[x];
    ans[x] = get_ans(idom[x]) + x;
    return ans[x];
}

int main() {
    while (~scanf("%d%d", &n, &m)) {
        init();
        for (int i = 1; i <= m; i++) {
            int x, y;
            input(x);
            input(y);
            a[x].push_back(y);
            b[y].push_back(x);//反向边用于找其直系爸爸和大于这个时间戳的和它有关的节点。
        }
        Lengauer_Tarjan();
        for (int i = 1; i <= n; i++)
            printf("%I64d%c", dfn[i] ? get_ans(i) : 0, i == n ? '\n' : ' ');
    }
    return 0;
}
```




